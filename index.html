<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <!-- iOS-friendly: prevents double-tap zoom from eating our gesture -->
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>DL engineer</title>
  <style>
    *{ box-sizing:border-box; }
    html,body{
      height:100%;
      margin:0;
      background:#fff;
      overflow:hidden;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      touch-action:none; /* important for iOS pointer events */
      -webkit-touch-callout:none;
      -webkit-user-select:none;
      user-select:none;
    }

    header{
      position:fixed; left:0; right:0; top:0;
      height:44px; display:flex; align-items:center;
      padding:0 14px; font-size:14px; font-weight:650;
      border-bottom:1px solid rgba(0,0,0,0.10);
      background:#fff; z-index:10;
    }

    /* Transparent FX overlay */
    #fx{
      position:fixed; inset:0;
      width:100vw; height:100vh;
      pointer-events:none;
      z-index:2000;
    }

    .runner{
      position:fixed; left:0; top:0;
      width:54px; height:54px;
      transform:translate(-50%,-50%);
      pointer-events:none;
      z-index:1000;
      filter:drop-shadow(0 10px 12px rgba(0,0,0,0.10));
      will-change:left,top;
    }

    .man{ width:54px; height:54px; transform-origin:50% 50%; will-change:transform; }
    .man svg{ width:54px; height:54px; display:block; }

    .bubble{
      position:absolute;
      left:62px; top:-4px;
      max-width:320px;
      padding:8px 10px;
      border-radius:14px;
      background:#fff;
      border:1px solid rgba(0,0,0,0.14);
      color:rgba(0,0,0,0.80);
      font-size:12px;
      line-height:1.25;
      box-shadow:0 12px 30px rgba(0,0,0,0.10);
      opacity:0;
      transform:translateY(-6px);
      transition:opacity .16s ease, transform .16s ease;
      white-space:normal;
      pointer-events:none;
    }
    .bubble.on{ opacity:1; transform:translateY(0); }
    .bubble:after{
      content:"";
      position:absolute;
      left:-6px; top:18px;
      width:10px; height:10px;
      background:#fff;
      border-left:1px solid rgba(0,0,0,0.14);
      border-bottom:1px solid rgba(0,0,0,0.14);
      transform:rotate(45deg);
    }

    .corpse{
      position:fixed; left:0; top:0;
      width:54px; height:54px;
      transform:translate(-50%,-50%);
      pointer-events:none;
      z-index:1400;
      filter:drop-shadow(0 12px 18px rgba(0,0,0,0.10));
      opacity:1;
      will-change:left,top,opacity,transform;
    }
    .corpse svg{ width:54px; height:54px; display:block; }
    .corpse.fade{ opacity:0; transition:opacity 520ms ease; }

    /* SOUL: monotone grey + X eyes */
    .soul{
      position:fixed; left:0; top:0;
      width:64px; height:64px;
      transform:translate(-50%,-50%);
      pointer-events:none;
      z-index:1500;
      opacity:0;
      filter:drop-shadow(0 10px 18px rgba(0,0,0,0.10));
      will-change:left,top,opacity;
    }
    .soul svg{ width:64px; height:64px; display:block; }
    .soul.on{ opacity:1; transition:opacity 200ms ease; }
  </style>
</head>
<body>
  <header>Fedorov Grigory | DL engineer | Pretrain Infra </header>
  <canvas id="fx"></canvas>

<script>
(() => {
  const isTouchMob = (('ontouchstart' in window) || (navigator.maxTouchPoints > 0));

  // limit on mobile
  const DESIRED_MEN = isTouchMob ? 4 : 10;
  const MAX_MEN     = isTouchMob ? 4 : 10;
  const EXPLOSION_RADIUS = 170;
  const HEADER_H = 44;

  // phrase when they surround cursor
  const CATCH_PHRASE = "there will be something here, but later, but for now go away";

  // announcer: one guy keeps repeating until he dies
  const ANNOUNCER = {
    intervalMs: 2200,
    phraseDesktop: "please don't right-click",
    phraseMobile: "please don't double-tap"
  };

  // double-tap detection thresholds
  const DOUBLE_TAP = {
    maxDelayMs: 330,
    maxDistPx: 24
  };

  // movement
  const CFG = {
    accel: 0.020,
    maxSpeed: 1.70,
    friction: 0.86,
    catchRadius: 14,
    stopMs: 240
  };

  // gather around cursor in a circle
  const ORBIT = { r: 56, jitter: 10 };

  // souls
  const SOUL = {
    risePxPerMs: 0.16,
    lifeMs: 6200,
    driftX: 240,
    waveAmp: [28, 46],
    waveFreq: [0.005, 0.009],
    fadeStart: 2600
  };

  // speech
  const SPEECH = {
    minGapMsBase: 9000,
    gapPanicMultiplier: 0.35,
    durationMs: 1600,
    cooldownPerManMs: 1400,

    heatHalfLifeMs: 8500,
    heatBoostPerExplosion: 1.0,

    escalationStep1: 3,
    escalationStep2: 6,
    escalationStep3: 10
  };

  const isTouch = (('ontouchstart' in window) || (navigator.maxTouchPoints > 0));

  // disable context menu (desktop right-click explosion)
  addEventListener("contextmenu", (e) => e.preventDefault());

  // pointer target (fallback if no movement yet)
  let target = { x: innerWidth * 0.65, y: innerHeight * 0.45 };
  let hasPointer = false;
  function setTarget(x, y){ hasPointer = true; target.x = x; target.y = y; }
  addEventListener("pointermove", (e) => setTarget(e.clientX, e.clientY), { passive: true });

  const men = [];

  // ===== SVGs =====
  function baseManSVG({ color, outline, deadEyes }) {
    const fill = color;
    const out = outline ? "rgba(0,0,0,0.30)" : "none";
    const outW = outline ? 2.2 : 0;

    const LIMB = 6.0;
    const THIGH = 7.0;
    const NECK = 3.2;

    const KNEE_CAP_W = 7.4;
    const KNEE_CAP_H = 5.0;

    const eyes = deadEyes ? `
      <g stroke="rgba(0,0,0,0.65)" stroke-width="1.6" stroke-linecap="round">
        <path d="M28.1 12.0 L30.7 14.6" />
        <path d="M30.7 12.0 L28.1 14.6" />
        <path d="M33.3 12.0 L35.9 14.6" />
        <path d="M35.9 12.0 L33.3 14.6" />
      </g>
    ` : "";

    return `
      <svg viewBox="0 0 64 78" aria-hidden="true">
        <g stroke="${out}" stroke-width="${outW}" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="32" cy="13.5" r="9.3" fill="${fill}" />
          ${eyes}

          <path d="M32 21 L32 29" stroke="${fill}" stroke-width="${NECK}" />
          <ellipse cx="32" cy="38" rx="8.9" ry="14.5" fill="${fill}" />

          <path d="M24 30 L12 38" stroke="${fill}" stroke-width="${LIMB}" />
          <path d="M40 30 L52 38" stroke="${fill}" stroke-width="${LIMB}" />

          <ellipse cx="32" cy="48" rx="8.2" ry="6.0" fill="${fill}" />

          <path d="M29 48 L23 61" stroke="${fill}" stroke-width="${THIGH}" />
          <path d="M35 48 L41 61" stroke="${fill}" stroke-width="${THIGH}" />

          <g class="shinL">
            <path d="M23 61 L30 76" stroke="${fill}" stroke-width="${LIMB}" />
          </g>
          <g class="shinR">
            <path d="M41 61 L34 76" stroke="${fill}" stroke-width="${LIMB}" />
          </g>

          <rect x="19.5" y="58.7" width="${KNEE_CAP_W}" height="${KNEE_CAP_H}" rx="3.2" fill="${fill}" />
          <rect x="37.1" y="58.7" width="${KNEE_CAP_W}" height="${KNEE_CAP_H}" rx="3.2" fill="${fill}" />
        </g>
      </svg>
    `;
  }
  function aliveSVG(){ return baseManSVG({ color:"#FFD400", outline:false, deadEyes:false }); }
  function soulSVG(){  return baseManSVG({ color:"#CFCFCF", outline:false, deadEyes:true  }); }
  function corpseSVG(){return baseManSVG({ color:"#F2F2F2", outline:false, deadEyes:true  }); }

  function makeRunnerElement(){
    const el = document.createElement("div");
    el.className = "runner";

    const man = document.createElement("div");
    man.className = "man";
    man.innerHTML = aliveSVG();

    const bubble = document.createElement("div");
    bubble.className = "bubble";
    bubble.textContent = "";

    el.appendChild(man);
    el.appendChild(bubble);
    document.body.appendChild(el);

    const svg = man.querySelector("svg");
    const parts = {
      shinL: svg.querySelector(".shinL"),
      shinR: svg.querySelector(".shinR"),
    };
    return { el, man, bubble, parts };
  }

  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function rand(a,b){ return a + Math.random()*(b-a); }
  function pick(arr){ return arr[(Math.random()*arr.length)|0]; }

  function randomSpawnPoint(){
    const pad = 26;
    const x = rand(pad, innerWidth - pad);
    const y = rand(HEADER_H + pad, innerHeight - pad);
    return { x, y };
  }

  function reassignOrbitSlots(){
    const orbiters = men.filter(m => m.alive && m.orbitAngle !== null);
    const n = orbiters.length;
    if (n === 0) return;
    const offset = (performance.now() * 0.00035) % (Math.PI * 2);
    for (let i = 0; i < n; i++) orbiters[i].orbitAngle = offset + i * (Math.PI * 2 / n);
  }

  function maintainPopulation(){
    while (men.length < DESIRED_MEN) {
      const p = randomSpawnPoint();
      spawnMan(p.x, p.y);
    }
  }

  // announcer ref
  let announcerRef = null;

  function spawnMan(x, y, { isAnnouncer=false } = {}){
    if (men.length >= MAX_MEN) return;
    y = clamp(y, HEADER_H, innerHeight);

    const { el, man, bubble, parts } = makeRunnerElement();
    const m = {
      el, man, bubble, parts,
      alive: true,
      pos: { x, y },
      vel: { x: 0, y: 0 },
      facing: 1,
      bobT: 0,
      phase: Math.random() * Math.PI * 2,
      stopUntil: 0,

      speakUntil: 0,
      lastSpeak: 0,

      orbitAngle: null,
      orbitRadius: ORBIT.r + (Math.random() - 0.5) * ORBIT.jitter,

      isAnnouncer,
      nextAnnounceAt: 0
    };

    el.style.left = x + "px";
    el.style.top  = y + "px";

    men.push(m);
    reassignOrbitSlots();
    applyPose(m, 0, 0);

    if (isAnnouncer) announcerRef = m;
  }

  function say(m, text, ms){
    if (!m || !m.alive) return;
    const now = performance.now();
    if (now - m.lastSpeak < SPEECH.cooldownPerManMs) return;

    m.lastSpeak = now;
    m.speakUntil = now + ms;
    m.bubble.textContent = text;
    m.bubble.classList.add("on");
  }

  function spawnCorpse(x, y, facing){
    const c = document.createElement("div");
    c.className = "corpse";
    c.style.left = x + "px";
    c.style.top  = y + "px";
    c.innerHTML = corpseSVG();

    const tilt = (Math.random() * 16 - 8);
    c.style.transform = `translate(-50%,-50%) rotate(${tilt}deg)`;

    const svg = c.querySelector("svg");
    svg.style.transformOrigin = "50% 50%";
    svg.style.transform = `scaleX(${facing})`;

    document.body.appendChild(c);

    setTimeout(() => c.classList.add("fade"), 520);
    setTimeout(() => c.remove(), 1100);
  }

  function spawnSoul(fromX, fromY, facing){
    const s = document.createElement("div");
    s.className = "soul";
    s.style.left = fromX + "px";
    s.style.top  = fromY + "px";
    s.innerHTML = soulSVG();
    document.body.appendChild(s);

    const svg = s.querySelector("svg");
    svg.style.transformOrigin = "50% 50%";
    svg.style.transform = `scaleX(${facing})`;

    requestAnimationFrame(() => s.classList.add("on"));

    const driftX = (Math.random() - 0.5) * SOUL.driftX;
    const waveA  = SOUL.waveAmp[0] + Math.random() * (SOUL.waveAmp[1] - SOUL.waveAmp[0]);
    const waveF  = SOUL.waveFreq[0] + Math.random() * (SOUL.waveFreq[1] - SOUL.waveFreq[0]);
    const rise   = SOUL.risePxPerMs * (0.9 + Math.random() * 0.25);
    const lifeMs = SOUL.lifeMs * (0.9 + Math.random() * 0.2);

    let t0 = null;
    const x0 = fromX, y0 = fromY;

    function step(ts){
      if (t0 === null) t0 = ts;
      const u = ts - t0;

      const nx = x0 + (driftX * (u / lifeMs)) + Math.sin(u * waveF) * waveA;
      const ny = y0 - (u * rise);

      s.style.left = nx + "px";
      s.style.top  = ny + "px";

      const fadeU = Math.max(0, u - SOUL.fadeStart);
      const alpha = Math.max(0, 1.0 - (fadeU / (lifeMs - SOUL.fadeStart)));
      s.style.opacity = alpha.toFixed(3);

      if (ny < -110 || u >= lifeMs || alpha <= 0.01) { s.remove(); return; }
      requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
  }

  function killMan(m){
    if (!m.alive) return;

    const x = m.pos.x, y = m.pos.y, facing = m.facing;
    m.alive = false;

    const idx = men.indexOf(m);
    if (idx >= 0) men.splice(idx, 1);

    if (m === announcerRef) announcerRef = null;

    try { m.el.remove(); } catch {}

    spawnCorpse(x, y, facing);
    setTimeout(() => spawnSoul(x, y, facing), 90);

    reassignOrbitSlots();
    maintainPopulation();
  }

  // ===== legs: shins only =====
  const KNEE_L = [23, 61];
  const KNEE_R = [41, 61];
  function rot(angleDeg, cx, cy){ return `rotate(${angleDeg.toFixed(2)} ${cx} ${cy})`; }

  function applyPose(m, speedPerMs, dt){
    const moving = speedPerMs > 0.08 && dt > 0;
    const freq = moving ? (7.2 + speedPerMs * 8.0) : 1.6;
    if (dt) m.phase += (dt / 1000) * freq;

    const s = Math.sin(m.phase);
    const base = 6;
    const amp  = moving ? 14 : 5;

    m.parts.shinL.setAttribute("transform", rot(base + amp * s, ...KNEE_L));
    m.parts.shinR.setAttribute("transform", rot(base - amp * s, ...KNEE_R));
  }

  // ===== explosion fx (no rings) =====
  const fx = document.getElementById("fx");
  const ctx = fx.getContext("2d", { alpha:true });

  function resizeFx(){
    const dpr = Math.max(1, Math.min(2, devicePixelRatio || 1));
    fx.width = Math.floor(innerWidth * dpr);
    fx.height = Math.floor(innerHeight * dpr);
    fx.style.width = innerWidth + "px";
    fx.style.height = innerHeight + "px";
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.clearRect(0,0,innerWidth,innerHeight);
  }
  resizeFx();
  addEventListener("resize", resizeFx);

  const explosions = [];

  function addExplosion(x,y){
    const e = { x,y, t:0, life:1100, fire:[], smoke:[], sparks:[] };

    const fireN = 120;
    for (let i=0;i<fireN;i++){
      const ang = rand(0, Math.PI*2);
      const sp  = rand(0.6, 4.8) * (0.65 + Math.random()*0.6);
      const up  = rand(-1.2, -4.0);
      e.fire.push({
        x: x + rand(-3,3), y: y + rand(-3,3),
        vx: Math.cos(ang)*sp, vy: Math.sin(ang)*sp + up,
        r: rand(10, 28), life: rand(340, 720), age:0,
        wob: rand(0, 10),
      });
    }

    const smokeN = 78;
    for (let i=0;i<smokeN;i++){
      const ang = rand(0, Math.PI*2);
      const sp  = rand(0.2, 2.1);
      e.smoke.push({
        x: x + rand(-6,6), y: y + rand(-6,6),
        vx: Math.cos(ang)*sp, vy: Math.sin(ang)*sp + rand(-2.2, -0.6),
        r: rand(18, 48), life: rand(740, 1280), age:0,
        dens: rand(0.10, 0.22), swirl: rand(0.004, 0.012),
      });
    }

    const sparkN = 46;
    for (let i=0;i<sparkN;i++){
      const ang = rand(0, Math.PI*2);
      const sp  = rand(3.0, 9.2);
      e.sparks.push({
        x,y,
        vx: Math.cos(ang)*sp, vy: Math.sin(ang)*sp + rand(-1.5, 0.5),
        life: rand(220, 560), age:0,
        w: rand(1.0, 1.8), l: rand(10, 22),
      });
    }

    explosions.push(e);
  }

  function drawExplosion(e, dt){
    e.t += dt;

    // smoke
    ctx.save();
    ctx.globalCompositeOperation = "source-over";
    for (const s of e.smoke){
      s.age += dt;
      const u = s.age / s.life;
      if (u >= 1) continue;

      const swirl = Math.sin((e.t + s.age) * s.swirl * 12) * 0.18;
      s.vx += swirl * dt * 0.002;
      s.vy += (-0.0006) * dt;

      s.x += s.vx * dt * 0.06;
      s.y += s.vy * dt * 0.06;

      const r = s.r * (0.75 + u * 1.45);
      const a = s.dens * (1 - u);

      const g = ctx.createRadialGradient(s.x - r*0.2, s.y - r*0.2, r*0.2, s.x, s.y, r);
      g.addColorStop(0, `rgba(40,40,40,${a*0.9})`);
      g.addColorStop(0.5, `rgba(55,55,55,${a*0.6})`);
      g.addColorStop(1, `rgba(55,55,55,0)`);
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(s.x, s.y, r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();

    // fire
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    for (const p of e.fire){
      p.age += dt;
      const u = p.age / p.life;
      if (u >= 1) continue;

      const wob = Math.sin((p.age + p.wob) * 0.02) * 0.05;
      p.vx *= (1 - dt*0.0012);
      p.vy *= (1 - dt*0.0010);
      p.vy += 0.0022 * dt;
      p.vx += wob * dt * 0.03;

      p.x += p.vx * dt * 0.08;
      p.y += p.vy * dt * 0.08;

      const rr = p.r * (0.7 + (1-u)*0.95);
      const a = (1 - u) * 0.65;

      const g = ctx.createRadialGradient(p.x - rr*0.25, p.y - rr*0.25, rr*0.18, p.x, p.y, rr);
      g.addColorStop(0, `rgba(255,255,255,${a*0.95})`);
      g.addColorStop(0.18, `rgba(255,235,160,${a*0.95})`);
      g.addColorStop(0.45, `rgba(255,155,40,${a*0.85})`);
      g.addColorStop(0.78, `rgba(255,70,0,${a*0.55})`);
      g.addColorStop(1, `rgba(60,20,0,0)`);
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(p.x, p.y, rr, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();

    // sparks
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    for (const sp of e.sparks){
      sp.age += dt;
      const u = sp.age / sp.life;
      if (u >= 1) continue;

      sp.vx *= (1 - dt*0.0016);
      sp.vy *= (1 - dt*0.0012);
      sp.vy += 0.0030 * dt;
      sp.x += sp.vx * dt * 0.12;
      sp.y += sp.vy * dt * 0.12;

      const a = (1-u) * 0.75;
      ctx.strokeStyle = `rgba(255,200,120,${a})`;
      ctx.lineWidth = sp.w;

      const nx = sp.x - sp.vx * sp.l * 0.05;
      const ny = sp.y - sp.vy * sp.l * 0.05;
      ctx.beginPath();
      ctx.moveTo(nx, ny);
      ctx.lineTo(sp.x, sp.y);
      ctx.stroke();
    }
    ctx.restore();

    return e.t >= e.life;
  }

  let lastFx = performance.now();
  function fxLoop(now){
    const dt = Math.min(32, Math.max(8, now - lastFx));
    lastFx = now;

    // fade by erasing, keeps canvas transparent
    ctx.save();
    ctx.globalCompositeOperation = "destination-out";
    ctx.fillStyle = "rgba(0,0,0,0.18)";
    ctx.fillRect(0, 0, innerWidth, innerHeight);
    ctx.restore();

    for (let i = explosions.length - 1; i >= 0; i--){
      const done = drawExplosion(explosions[i], dt);
      if (done) explosions.splice(i, 1);
    }
    requestAnimationFrame(fxLoop);
  }
  requestAnimationFrame(fxLoop);

  // ===== warnings (mobile uses double-tap) =====
  const desktopWarnings = [
    "please don't right-click",
    "no right-click, please",
    "please stop right-clicking",
    "please don't do that",
    "no explosions, please"
  ];
  const mobileWarnings = [
    "please don't double-tap",
    "no double-tap, please",
    "please stop double-tapping",
    "please don't do that",
    "no explosions, please"
  ];

  // ===== smart speech: panic + escalation =====
  let explosionCount = 0;
  let heat = 0;
  let lastHeatUpdate = performance.now();

  function updateHeat(now){
    const dt = now - lastHeatUpdate;
    lastHeatUpdate = now;
    const decay = Math.pow(0.5, dt / SPEECH.heatHalfLifeMs);
    heat *= decay;
  }
  function addHeat(now){
    updateHeat(now);
    heat += SPEECH.heatBoostPerExplosion;
  }
  function heatLevel(now){
    updateHeat(now);
    return 1 - Math.exp(-heat * 0.55);
  }
  function escalationLevel(){
    if (explosionCount >= SPEECH.escalationStep3) return 3;
    if (explosionCount >= SPEECH.escalationStep2) return 2;
    if (explosionCount >= SPEECH.escalationStep1) return 1;
    return 0;
  }
  function speechPool(){
    return isTouch ? mobileWarnings : desktopWarnings;
  }

  let nextChatterAt = performance.now() + 4500 + Math.random()*4500;

  function scheduleNextChatter(now){
    const hl = heatLevel(now);
    const gapBase = SPEECH.minGapMsBase;
    const gap = gapBase * (1 - hl * (1 - SPEECH.gapPanicMultiplier));
    nextChatterAt = now + gap + Math.random() * gap * 0.85;
  }

  function maybeChatter(now){
    if (now < nextChatterAt) return;
    scheduleNextChatter(now);

    if (men.length === 0) return;

    const hl = heatLevel(now);
    const esc = escalationLevel();
    const chance = clamp(0.22 + hl*0.55 + esc*0.06, 0, 0.90);
    if (Math.random() > chance) return;

    const m = men[(Math.random()*men.length)|0];
    if (!m || !m.alive) return;
    if (m.bubble.classList.contains("on")) return;

    say(m, pick(speechPool()), SPEECH.durationMs);
  }

  // ===== explosion logic =====
  function explode(x, y){
    const now = performance.now();
    explosionCount++;
    addHeat(now);

    addExplosion(x, y);

    const snapshot = [...men];
    for (const m of snapshot) {
      if (!m.alive) continue;
      const dx = m.pos.x - x;
      const dy = m.pos.y - y;
      if (Math.hypot(dx, dy) <= EXPLOSION_RADIUS) killMan(m);
    }

    // immediate complain sometimes
    if (men.length > 0) {
      const hl = heatLevel(now);
      const immediateChance = clamp(0.18 + hl*0.52, 0, 0.88);
      if (Math.random() < immediateChance) {
        const m = men[(Math.random()*men.length)|0];
        if (m && m.alive && !m.bubble.classList.contains("on")) {
          say(m, pick(speechPool()), 1200);
        }
      }
    }
  }

  // ===== inputs =====

  // desktop: right-click explosion
  addEventListener("pointerdown", (e) => {
    setTarget(e.clientX, e.clientY);
    if (e.button === 2) {
      e.preventDefault();
      explode(e.clientX, e.clientY);
    }
  }, { passive: false });

  // mobile: double tap via pointer events (more reliable on iOS)
  let lastTouchUpTime = 0;
  let lastTouchX = 0;
  let lastTouchY = 0;

  function isNear(x1,y1,x2,y2,maxDist){
    return Math.hypot(x1-x2, y1-y2) <= maxDist;
  }

  addEventListener("pointerdown", (e) => {
    if (e.pointerType === "touch") {
      setTarget(e.clientX, e.clientY);
      e.preventDefault();
    }
  }, { passive: false });

  addEventListener("pointermove", (e) => {
    if (e.pointerType === "touch") {
      setTarget(e.clientX, e.clientY);
      e.preventDefault();
    }
  }, { passive: false });

  addEventListener("pointerup", (e) => {
    if (e.pointerType !== "touch") return;

    e.preventDefault();
    const now = performance.now();
    const x = e.clientX, y = e.clientY;

    setTarget(x, y);

    const dt = now - lastTouchUpTime;
    const dist = isNear(x, y, lastTouchX, lastTouchY, DOUBLE_TAP.maxDistPx);

    if (lastTouchUpTime > 0 && dt <= DOUBLE_TAP.maxDelayMs && dist) {
      lastTouchUpTime = 0;
      explode(x, y);
      return;
    }

    lastTouchUpTime = now;
    lastTouchX = x;
    lastTouchY = y;
  }, { passive: false });

  // ===== init population =====
  function init(){
    // announcer first
    const a = randomSpawnPoint();
    spawnMan(a.x, a.y, { isAnnouncer: true });

    // rest
    for (let i = 1; i < DESIRED_MEN; i++) {
      const p = randomSpawnPoint();
      spawnMan(p.x, p.y);
    }

    maintainPopulation();
    scheduleNextChatter(performance.now());

    if (announcerRef) announcerRef.nextAnnounceAt = performance.now();
  }
  requestAnimationFrame(() => requestAnimationFrame(init));

  // ===== main tick =====
  function clampDt(v){ return Math.max(8, Math.min(28, v)); }

  function tick(now){
    const dt = clampDt(now - (tick._last || now));
    tick._last = now;

    if (!hasPointer) { target.x = innerWidth * 0.65; target.y = innerHeight * 0.45; }

    // announcer repeats until death
    if (announcerRef && announcerRef.alive) {
      const phrase = isTouch ? ANNOUNCER.phraseMobile : ANNOUNCER.phraseDesktop;
      if (now >= announcerRef.nextAnnounceAt && !announcerRef.bubble.classList.contains("on")) {
        announcerRef.lastSpeak = 0; // avoid cooldown blocking
        say(announcerRef, phrase, 1600);
        announcerRef.nextAnnounceAt = now + ANNOUNCER.intervalMs;
      }
    }

    maybeChatter(now);

    for (const m of men) {
      if (!m.alive) continue;

      const stopped = now < m.stopUntil;

      // orbit target
      let tx = target.x;
      let ty = target.y;
      if (m.orbitAngle !== null) {
        tx = target.x + Math.cos(m.orbitAngle) * m.orbitRadius;
        ty = target.y + Math.sin(m.orbitAngle) * m.orbitRadius;
      }
      ty = clamp(ty, HEADER_H, innerHeight);

      if (!stopped) {
        const dx = tx - m.pos.x;
        const dy = ty - m.pos.y;
        const dist = Math.hypot(dx, dy) || 1;

        if (Math.abs(dx) > 2) m.facing = dx >= 0 ? 1 : -1;

        const ax = (dx / dist) * CFG.accel * dt;
        const ay = (dy / dist) * CFG.accel * dt;

        m.vel.x = (m.vel.x + ax) * CFG.friction;
        m.vel.y = (m.vel.y + ay) * CFG.friction;

        const sp = Math.hypot(m.vel.x, m.vel.y) || 1;
        const maxV = CFG.maxSpeed * dt;
        if (sp > maxV) {
          m.vel.x = (m.vel.x / sp) * maxV;
          m.vel.y = (m.vel.y / sp) * maxV;
        }

        m.pos.x += m.vel.x;
        m.pos.y += m.vel.y;

        m.pos.x = clamp(m.pos.x, 0, innerWidth);
        m.pos.y = clamp(m.pos.y, HEADER_H, innerHeight);

        const distToCursor = Math.hypot(target.x - m.pos.x, target.y - m.pos.y);
        if (distToCursor < CFG.catchRadius) {
          if (m.orbitAngle === null) {
            m.orbitAngle = 0;
            reassignOrbitSlots();
          }

          const ox = target.x + Math.cos(m.orbitAngle) * m.orbitRadius;
          const oy = clamp(target.y + Math.sin(m.orbitAngle) * m.orbitRadius, HEADER_H, innerHeight);

          m.pos.x = ox;
          m.pos.y = oy;
          m.vel.x = 0; m.vel.y = 0;
          m.stopUntil = now + CFG.stopMs;

          // show "go away" when they surround cursor
          if (now - m.lastSpeak > SPEECH.cooldownPerManMs && !m.bubble.classList.contains("on")) {
            say(m, CATCH_PHRASE, 1400);
          }
        }
      }

      if (m.bubble.classList.contains("on") && now > m.speakUntil) {
        m.bubble.classList.remove("on");
      }

      const speedNow = Math.hypot(m.vel.x, m.vel.y);
      const speedPerMs = speedNow / dt;

      applyPose(m, speedPerMs, dt);

      const moving = !stopped && speedPerMs > 0.08;
      m.bobT += dt * 0.01 * (moving ? 1.2 : 0.6);
      const bob = Math.sin(m.bobT) * (moving ? 0.45 : 0.16);

      m.el.style.left = m.pos.x + "px";
      m.el.style.top  = (m.pos.y + bob) + "px";
      m.man.style.transform = `scaleX(${m.facing})`;
    }

    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  addEventListener("resize", () => {
    for (const m of men) {
      m.pos.x = clamp(m.pos.x, 0, innerWidth);
      m.pos.y = clamp(m.pos.y, HEADER_H, innerHeight);
    }
    resizeFx();
  });
})();
</script>
</body>
</html>
