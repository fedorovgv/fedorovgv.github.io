
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DL engineer</title>
  <style>
    *{ box-sizing:border-box; }
    html,body{ height:100%; margin:0; background:#fff; overflow:hidden; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; }

    header{
      position:fixed; left:0; right:0; top:0;
      height:44px; display:flex; align-items:center;
      padding:0 14px; font-size:14px; font-weight:650;
      border-bottom:1px solid rgba(0,0,0,0.10);
      background:#fff; user-select:none; z-index:10;
    }

    .runner{
      position:fixed;
      left:0; top:0;
      width:52px; height:52px;       /* small but readable */
      transform:translate(-50%,-50%);
      pointer-events:none;
      z-index:1000;
      filter:drop-shadow(0 10px 12px rgba(0,0,0,0.10));
      will-change:left,top;
    }

    .man{ width:52px; height:52px; transform-origin:50% 50%; will-change:transform,opacity; }
    .man svg{ width:52px; height:52px; display:block; }

    .runner.dying .man{
      opacity:0;
      transform:scaleX(var(--face,1)) scale(0.92);
      transition:opacity 140ms ease, transform 180ms ease;
    }

    .bubble{
      position:absolute;
      left:60px;
      top:-4px;
      max-width:320px;
      padding:8px 10px;
      border-radius:14px;
      background:#fff;
      border:1px solid rgba(0,0,0,0.14);
      color:rgba(0,0,0,0.80);
      font-size:12px;
      line-height:1.25;
      box-shadow:0 12px 30px rgba(0,0,0,0.10);
      opacity:0;
      transform:translateY(-6px);
      transition:opacity .16s ease, transform .16s ease;
      white-space:normal;
    }
    .bubble.on{ opacity:1; transform:translateY(0); }
    .bubble:after{
      content:"";
      position:absolute;
      left:-6px; top:18px;
      width:10px; height:10px;
      background:#fff;
      border-left:1px solid rgba(0,0,0,0.14);
      border-bottom:1px solid rgba(0,0,0,0.14);
      transform:rotate(45deg);
    }

    .soul{
      position:fixed;
      left:0; top:0;
      width:62px; height:62px;
      transform:translate(-50%,-50%);
      pointer-events:none;
      z-index:1500;
      opacity:0;
      filter:
        drop-shadow(0 12px 22px rgba(0,0,0,0.12))
        drop-shadow(0 0 14px rgba(255,255,255,0.98));
      will-change:left,top,opacity;
    }
    .soul svg{ width:62px; height:62px; display:block; }
    .soul.on{ opacity:1; transition:opacity 180ms ease; }

    /* explosion visuals (same as before) */
    .boom{ position:fixed; left:0; top:0; width:10px; height:10px; transform:translate(-50%,-50%); pointer-events:none; z-index:2000; mix-blend-mode:multiply; filter:saturate(1.25); }
    .boom .shock{ position:absolute; left:50%; top:50%; width:20px; height:20px; border-radius:999px; border:2px solid rgba(255,70,0,0.38); transform:translate(-50%,-50%) scale(0.12); opacity:0.95; animation:shock 620ms cubic-bezier(.1,.8,.2,1) forwards; }
    .boom .flash{ position:absolute; left:50%; top:50%; width:26px; height:26px; border-radius:999px; transform:translate(-50%,-50%) scale(0.12); background:radial-gradient(circle at 35% 35%, rgba(255,255,255,0.95) 0%, rgba(255,220,120,0.95) 22%, rgba(255,120,0,0.85) 48%, rgba(255,40,0,0.55) 72%, rgba(255,40,0,0.0) 100%); animation:flash 520ms ease-out forwards; opacity:1; filter:blur(0.2px); }
    .boom .puff{ position:absolute; left:50%; top:50%; width:var(--s); height:var(--s); border-radius:999px; transform:translate(-50%,-50%) scale(0.12); opacity:0.9; background:radial-gradient(circle at 35% 35%, rgba(255,255,255,0.85) 0%, rgba(255,230,140,0.85) 22%, rgba(255,140,0,0.78) 50%, rgba(255,55,0,0.45) 78%, rgba(255,55,0,0.00) 100%); filter:blur(0.4px); animation:puff 760ms cubic-bezier(.12,.8,.18,1) forwards; }
    .boom .smoke{ position:absolute; left:50%; top:50%; width:var(--s); height:var(--s); border-radius:999px; transform:translate(-50%,-50%) scale(0.12); opacity:0.45; background:radial-gradient(circle at 40% 40%, rgba(60,60,60,0.35) 0%, rgba(60,60,60,0.22) 45%, rgba(60,60,60,0.00) 100%); filter:blur(0.9px); animation:smoke 980ms cubic-bezier(.12,.8,.18,1) forwards; mix-blend-mode:normal; }

    @keyframes flash{ 0%{transform:translate(-50%,-50%) scale(.12);opacity:.95;} 35%{transform:translate(-50%,-50%) scale(1.25);opacity:.75;} 100%{transform:translate(-50%,-50%) scale(2.25);opacity:0;} }
    @keyframes shock{ 0%{transform:translate(-50%,-50%) scale(.12);opacity:.9;} 100%{transform:translate(-50%,-50%) scale(3.2);opacity:0;} }
    @keyframes puff{ 0%{transform:translate(-50%,-50%) scale(.18);opacity:.9;} 55%{opacity:.55;} 100%{transform:translate(calc(-50% + var(--dx)),calc(-50% + var(--dy))) scale(1.65);opacity:0;} }
    @keyframes smoke{ 0%{transform:translate(-50%,-50%) scale(.18);opacity:.18;} 35%{opacity:.30;} 100%{transform:translate(calc(-50% + var(--dx)),calc(-50% + var(--dy))) scale(2.1);opacity:0;} }
  </style>
</head>
<body>
  <header>DL engineer</header>

<script>
(() => {
  const MAX_MEN = 15;
  const EXPLOSION_RADIUS = 140;
  const HEADER_H = 44;

  const CFG = {
    accel: 0.020,
    maxSpeed: 1.70,
    friction: 0.86,
    catchRadius: 14,
    stopMs: 240,
    speakMs: 1300,
    speakCooldownMs: 650,
  };

  const SOUL = {
    risePxPerMs: 0.28,
    lifeMs: 4200,
    driftX: 220,
    waveAmp: [22, 32],
    waveFreq: [0.006, 0.010],
    fadeStart: 1600,
  };

  addEventListener("contextmenu", (e) => e.preventDefault());

  let target = { x: innerWidth * 0.6, y: innerHeight * 0.6 };
  let hasPointer = false;
  function setTarget(x, y){ hasPointer = true; target.x = x; target.y = y; }
  addEventListener("pointermove", (e) => setTarget(e.clientX, e.clientY), { passive: true });

  const men = [];

  // "Цельный" человек: сегменты-капсулы + суставы-кружки.
  // Ноги нормальной длины, бедро+голень, колено сгибается.
  function manSVG({ color, outline }) {
    const fill = color;
    const out = outline ? "rgba(0,0,0,0.30)" : "none";
    const outW = outline ? 2.0 : 0;

    const SW = 7.2; // thinner
    const JR = 4.2; // joint radius
    const FR = 3.6; // foot joint

    return `
      <svg viewBox="0 0 64 64" aria-hidden="true">
        <g stroke="${out}" stroke-width="${outW}" stroke-linecap="round" stroke-linejoin="round">
          <!-- head -->
          <circle cx="32" cy="14.5" r="8.8" fill="${fill}" />

          <!-- torso (slim) -->
          <ellipse cx="32" cy="33" rx="8.6" ry="12.8" fill="${fill}" />

          <!-- arms (fixed, small) -->
          <path d="M25 28.5 L17 34.5" stroke="${fill}" stroke-width="${SW}" />
          <circle cx="25" cy="28.5" r="${JR}" fill="${fill}" />
          <circle cx="17" cy="34.5" r="${JR}" fill="${fill}" />

          <path d="M39 28.5 L47 34.5" stroke="${fill}" stroke-width="${SW}" />
          <circle cx="39" cy="28.5" r="${JR}" fill="${fill}" />
          <circle cx="47" cy="34.5" r="${JR}" fill="${fill}" />

          <!-- hips cover -->
          <circle cx="32" cy="42" r="5.6" fill="${fill}"/>

          <!-- thighs (animated groups) -->
          <g class="thighL">
            <path d="M30 42 L26 52" stroke="${fill}" stroke-width="${SW}" />
            <circle cx="30" cy="42" r="${JR}" fill="${fill}" />
            <circle cx="26" cy="52" r="${JR}" fill="${fill}" />

            <g class="shinL">
              <path d="M26 52 L30 62" stroke="${fill}" stroke-width="${SW}" />
              <circle cx="26" cy="52" r="${JR}" fill="${fill}" />
              <circle cx="30" cy="62" r="${FR}" fill="${fill}" />
              <path d="M28 62 L35 62" stroke="${fill}" stroke-width="${SW-0.6}" />
            </g>
          </g>

          <g class="thighR">
            <path d="M34 42 L38 52" stroke="${fill}" stroke-width="${SW}" />
            <circle cx="34" cy="42" r="${JR}" fill="${fill}" />
            <circle cx="38" cy="52" r="${JR}" fill="${fill}" />

            <g class="shinR">
              <path d="M38 52 L34 62" stroke="${fill}" stroke-width="${SW}" />
              <circle cx="38" cy="52" r="${JR}" fill="${fill}" />
              <circle cx="34" cy="62" r="${FR}" fill="${fill}" />
              <path d="M29 62 L36 62" stroke="${fill}" stroke-width="${SW-0.6}" />
            </g>
          </g>
        </g>
      </svg>
    `;
  }

  function makeRunnerElement(){
    const el = document.createElement("div");
    el.className = "runner";

    const man = document.createElement("div");
    man.className = "man";
    man.innerHTML = manSVG({ color: "#FFD400", outline: false });

    const bubble = document.createElement("div");
    bubble.className = "bubble";
    bubble.textContent = "smnth will be later here, now go away";

    el.appendChild(man);
    el.appendChild(bubble);
    document.body.appendChild(el);

    const svg = man.querySelector("svg");
    const parts = {
      thighL: svg.querySelector(".thighL"),
      shinL:  svg.querySelector(".shinL"),
      thighR: svg.querySelector(".thighR"),
      shinR:  svg.querySelector(".shinR"),
    };
    return { el, man, bubble, parts };
  }

  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  function spawnMan(x, y){
    if (men.length >= MAX_MEN) return;
    y = clamp(y, HEADER_H, innerHeight);
    const { el, man, bubble, parts } = makeRunnerElement();

    const m = {
      el, man, bubble, parts,
      alive: true,
      dying: false,
      pos: { x, y },
      vel: { x: 0, y: 0 },
      facing: 1,
      bobT: 0,
      phase: Math.random() * Math.PI * 2,
      stopUntil: 0,
      speakUntil: 0,
      lastSpeak: 0,
    };

    el.style.left = x + "px";
    el.style.top  = y + "px";
    men.push(m);
    applyPose(m, 0, 0);
  }

  function spawnSoul(fromX, fromY, facing){
    const s = document.createElement("div");
    s.className = "soul";
    s.style.left = fromX + "px";
    s.style.top  = fromY + "px";
    s.innerHTML = manSVG({ color: "#FFFFFF", outline: true });
    document.body.appendChild(s);

    const svg = s.querySelector("svg");
    svg.style.transformOrigin = "50% 50%";
    svg.style.transform = `scaleX(${facing})`;

    requestAnimationFrame(() => s.classList.add("on"));

    const driftX = (Math.random() - 0.5) * SOUL.driftX;
    const waveA  = SOUL.waveAmp[0] + Math.random() * (SOUL.waveAmp[1] - SOUL.waveAmp[0]);
    const waveF  = SOUL.waveFreq[0] + Math.random() * (SOUL.waveFreq[1] - SOUL.waveFreq[0]);
    const rise   = SOUL.risePxPerMs * (0.9 + Math.random() * 0.25);
    const lifeMs = SOUL.lifeMs * (0.9 + Math.random() * 0.2);

    let t0 = null;
    const x0 = fromX, y0 = fromY;

    function step(ts){
      if (t0 === null) t0 = ts;
      const u = ts - t0;

      const nx = x0 + (driftX * (u / lifeMs)) + Math.sin(u * waveF) * waveA;
      const ny = y0 - (u * rise);

      s.style.left = nx + "px";
      s.style.top  = ny + "px";

      const fadeU = Math.max(0, u - SOUL.fadeStart);
      const alpha = Math.max(0, 1.0 - (fadeU / (lifeMs - SOUL.fadeStart)));
      s.style.opacity = alpha.toFixed(3);

      if (ny < -100 || u >= lifeMs || alpha <= 0.01) {
        s.remove();
        return;
      }
      requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
  }

  function killMan(m){
    if (!m.alive || m.dying) return;
    m.dying = true;

    const facing = m.facing;
    m.el.style.setProperty("--face", String(facing));
    m.el.classList.add("dying");

    setTimeout(() => spawnSoul(m.pos.x, m.pos.y, facing), 90);

    setTimeout(() => {
      m.alive = false;
      m.el.remove();
      const idx = men.indexOf(m);
      if (idx >= 0) men.splice(idx, 1);
    }, 260);
  }

  // --- Leg animation (thigh + shin, with knee bend) ---
  // Pivots in viewBox coords:
  const HIP_L  = [30, 42];
  const KNEE_L = [26, 52];
  const HIP_R  = [34, 42];
  const KNEE_R = [38, 52];

  function rot(angleDeg, cx, cy){
    return `rotate(${angleDeg.toFixed(2)} ${cx} ${cy})`;
  }

  function applyPose(m, speedPerMs, dt){
    const moving = speedPerMs > 0.08 && dt > 0;
    const freq = moving ? (7.0 + speedPerMs * 10.0) : 1.6; // rad/sec
    if (dt) m.phase += (dt / 1000) * freq;

    const s = Math.sin(m.phase);

    // subtle but readable
    const thighAmp = moving ? 18 : 6;
    const shinAmp  = moving ? 26 : 8;

    const thighL = -thighAmp * s;
    const thighR =  thighAmp * s;

    // knee bends more when leg is forward
    const bendL = 18 + shinAmp * Math.max(0,  s);
    const bendR = 18 + shinAmp * Math.max(0, -s);

    m.parts.thighL.setAttribute("transform", rot(thighL, ...HIP_L));
    m.parts.shinL.setAttribute("transform",  rot(bendL,  ...KNEE_L));

    m.parts.thighR.setAttribute("transform", rot(thighR, ...HIP_R));
    m.parts.shinR.setAttribute("transform",  rot(bendR,  ...KNEE_R));
  }

  // Explosion visuals
  function fireballExplosion(x, y){
    const b = document.createElement("div");
    b.className = "boom";
    b.style.left = x + "px";
    b.style.top  = y + "px";

    const shock = document.createElement("div");
    shock.className = "shock";
    const flash = document.createElement("div");
    flash.className = "flash";
    b.appendChild(flash);
    b.appendChild(shock);

    const puffs = 9;
    for (let i = 0; i < puffs; i++) {
      const puff = document.createElement("div");
      puff.className = "puff";
      const ang = (Math.PI * 2) * (i / puffs) + (Math.random() * 0.35);
      const r = 20 + Math.random() * 34;
      puff.style.setProperty("--dx", (Math.cos(ang) * r) + "px");
      puff.style.setProperty("--dy", (Math.sin(ang) * r) + "px");
      puff.style.setProperty("--s", (26 + Math.random() * 34) + "px");
      puff.style.animationDuration = (680 + Math.random() * 240) + "ms";
      b.appendChild(puff);
    }

    const smokeCount = 6;
    for (let i = 0; i < smokeCount; i++) {
      const s = document.createElement("div");
      s.className = "smoke";
      const ang = (Math.PI * 2) * (i / smokeCount) + (Math.random() * 0.6);
      const r = 30 + Math.random() * 44;
      s.style.setProperty("--dx", (Math.cos(ang) * r) + "px");
      s.style.setProperty("--dy", (Math.sin(ang) * r - (8 + Math.random() * 16)) + "px");
      s.style.setProperty("--s", (34 + Math.random() * 44) + "px");
      s.style.animationDelay = (60 + Math.random() * 90) + "ms";
      b.appendChild(s);
    }

    document.body.appendChild(b);
    setTimeout(() => b.remove(), 1100);
  }

  function explode(x, y){
    fireballExplosion(x, y);
    for (const m of [...men]) {
      if (!m.alive) continue;
      const dx = m.pos.x - x;
      const dy = m.pos.y - y;
      if (Math.hypot(dx, dy) <= EXPLOSION_RADIUS) killMan(m);
    }
  }

  addEventListener("pointerdown", (e) => {
    if (e.button === 2) {
      e.preventDefault();
      explode(e.clientX, e.clientY);
      return;
    }
    setTarget(e.clientX, e.clientY);
    spawnMan(e.clientX, e.clientY);
  }, { passive: false });

  // Seed
  requestAnimationFrame(() => requestAnimationFrame(() => {
    spawnMan(innerWidth * 0.30, innerHeight * 0.60);
    spawnMan(innerWidth * 0.22, innerHeight * 0.70);
    target = { x: innerWidth * 0.70, y: innerHeight * 0.44 };
  }));

  function tick(now){
    const dt = clamp(now - (tick._last || now), 8, 28);
    tick._last = now;

    if (!hasPointer) { target.x = innerWidth * 0.70; target.y = innerHeight * 0.44; }

    for (const m of men) {
      if (!m.alive || m.dying) continue;

      const stopped = now < m.stopUntil;

      if (!stopped) {
        const dx = target.x - m.pos.x;
        const dy = target.y - m.pos.y;
        const dist = Math.hypot(dx, dy) || 1;

        if (Math.abs(dx) > 2) m.facing = dx >= 0 ? 1 : -1;

        const ax = (dx / dist) * CFG.accel * dt;
        const ay = (dy / dist) * CFG.accel * dt;

        m.vel.x = (m.vel.x + ax) * CFG.friction;
        m.vel.y = (m.vel.y + ay) * CFG.friction;

        const sp = Math.hypot(m.vel.x, m.vel.y) || 1;
        const maxV = CFG.maxSpeed * dt;
        if (sp > maxV) {
          m.vel.x = (m.vel.x / sp) * maxV;
          m.vel.y = (m.vel.y / sp) * maxV;
        }

        m.pos.x += m.vel.x;
        m.pos.y += m.vel.y;

        m.pos.x = clamp(m.pos.x, 0, innerWidth);
        m.pos.y = clamp(m.pos.y, HEADER_H, innerHeight);

        if (dist < CFG.catchRadius) {
          m.pos.x = target.x;
          m.pos.y = target.y;
          m.vel.x = 0; m.vel.y = 0;
          m.stopUntil = now + CFG.stopMs;

          if (now - m.lastSpeak > CFG.speakCooldownMs) {
            m.lastSpeak = now;
            m.speakUntil = now + CFG.speakMs;
            m.bubble.classList.add("on");
          }
        }
      }

      if (m.bubble.classList.contains("on") && now > m.speakUntil) {
        m.bubble.classList.remove("on");
      }

      const speedNow = Math.hypot(m.vel.x, m.vel.y);
      const speedPerMs = speedNow / dt;

      applyPose(m, speedPerMs, dt);

      // minimal bob
      const moving = !stopped && speedPerMs > 0.08;
      m.bobT += dt * 0.01 * (moving ? 1.6 : 0.6);
      const bob = Math.sin(m.bobT) * (moving ? 0.7 : 0.25);

      m.el.style.left = m.pos.x + "px";
      m.el.style.top  = (m.pos.y + bob) + "px";
      m.man.style.transform = `scaleX(${m.facing})`;
    }

    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>

