
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DL engineer</title>
  <style>
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: #fff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }

    /* Minimal header */
    header{
      height: 44px;
      display: flex;
      align-items: center;
      padding: 0 14px;
      font-size: 14px;
      font-weight: 650;
      border-bottom: 1px solid rgba(0,0,0,0.10);
      user-select: none;
    }

    /* Full-screen writing area */
    textarea{
      position: fixed;
      left: 0; right: 0;
      top: 44px; bottom: 0;
      width: 100%;
      height: calc(100% - 44px);
      border: 0;
      outline: none;
      resize: none;
      background: #fff;
      color: #000;
      padding: 16px 14px;
      font-size: 16px;
      line-height: 1.55;
    }
    textarea::placeholder{ color: rgba(0,0,0,0.25); }

    /* Little man */
    .runner{
      position: fixed;
      left: 0; top: 0;
      width: 54px; height: 54px;
      transform: translate(-50%, -50%); /* center anchor */
      pointer-events: none;
      z-index: 999999;
      filter: drop-shadow(0 10px 10px rgba(0,0,0,0.10));
      will-change: left, top, transform, opacity;
    }
    .man{
      width: 54px; height: 54px;
      transform-origin: 50% 50%;
      transform: scaleX(1);
    }
    .man svg { width: 54px; height: 54px; display: block; }

    /* Death effect */
    .runner.dead{
      opacity: 0;
      transform: translate(-50%, -50%) scale(0.25);
      transition: opacity 180ms ease, transform 220ms ease;
    }

    /* Speech bubble */
    .bubble{
      position:absolute;
      left: 58px;
      top: -4px;
      max-width: 280px;
      padding: 8px 10px;
      border-radius: 14px;
      background: #fff;
      border: 1px solid rgba(0,0,0,0.14);
      color: rgba(0,0,0,0.80);
      font-size: 12px;
      line-height: 1.25;
      box-shadow: 0 12px 30px rgba(0,0,0,0.10);
      opacity: 0;
      transform: translateY(-6px);
      transition: opacity .16s ease, transform .16s ease;
      white-space: normal;
    }
    .bubble.on{ opacity: 1; transform: translateY(0); }
    .bubble:after{
      content:"";
      position:absolute;
      left: -6px; top: 18px;
      width: 10px; height: 10px;
      background: #fff;
      border-left: 1px solid rgba(0,0,0,0.14);
      border-bottom: 1px solid rgba(0,0,0,0.14);
      transform: rotate(45deg);
    }

    /* Minimal explosion */
    .explosion{
      position: fixed;
      left: 0; top: 0;
      width: 10px; height: 10px;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 1000000;
    }
    .explosion:before, .explosion:after{
      content:"";
      position:absolute;
      inset: -2px;
      border-radius: 999px;
      border: 2px solid rgba(0,0,0,0.25);
      transform: scale(0.12);
      opacity: 0.9;
      animation: boom 520ms ease-out forwards;
    }
    .explosion:after{
      border-width: 1px;
      border-color: rgba(0,0,0,0.18);
      animation-duration: 620ms;
      animation-delay: 20ms;
    }
    .explosion .dot{
      position:absolute;
      left: 50%; top: 50%;
      width: 3px; height: 3px;
      border-radius: 999px;
      background: rgba(0,0,0,0.22);
      transform: translate(-50%, -50%) scale(0.7);
      opacity: 0.9;
      animation: dot 560ms ease-out forwards;
    }
    @keyframes boom{
      0%   { transform: scale(0.10); opacity: 0.95; }
      70%  { opacity: 0.55; }
      100% { transform: scale(1.9); opacity: 0; }
    }
    @keyframes dot{
      0%   { opacity: 0.9; transform: translate(-50%, -50%) scale(0.7); }
      100% { opacity: 0; transform: translate(var(--dx), var(--dy)) scale(1.0); }
    }
  </style>
</head>
<body>
  <header>DL engineer</header>
  <textarea id="note" placeholder="write…"></textarea>

  <script>
  (() => {
    // ----- Config -----
    const MAX_MEN = 15;
    const EXPLOSION_RADIUS = 120; // px
    const EXPLOSION_DOTS = 10;

    // Movement
    const prefersReducedMotion = window.matchMedia?.("(prefers-reduced-motion: reduce)")?.matches;
    const CFG = {
      accel: prefersReducedMotion ? 0.004 : 0.020,
      maxSpeed: prefersReducedMotion ? 0.45 : 1.55, // px/ms
      friction: 0.86,
      catchRadius: 12,
      stopMs: 260,
      speakMs: 1400,
      speakCooldownMs: 650,
    };

    const note = document.getElementById("note");

    // Prevent context menu so ПКМ works
    window.addEventListener("contextmenu", (e) => e.preventDefault());

    // Cursor target
    let target = { x: window.innerWidth * 0.6, y: window.innerHeight * 0.6 };
    let hasPointer = false;

    function setTarget(x, y) {
      hasPointer = true;
      target.x = x;
      target.y = y;
    }

    window.addEventListener("pointermove", (e) => setTarget(e.clientX, e.clientY), { passive: true });

    // Men state
    const men = [];

    function makeRunnerElement() {
      const el = document.createElement("div");
      el.className = "runner";

      const man = document.createElement("div");
      man.className = "man";
      man.innerHTML = `
        <svg viewBox="0 0 64 64" aria-hidden="true">
          <circle cx="30" cy="14" r="9" fill="#FFD400"/>
          <path d="M24 24 C24 20, 36 20, 36 24 L38 40 C38 46, 22 46, 22 40 Z" fill="#FFD400"/>
          <path d="M23 27 C16 28, 12 33, 11 37 C10 40, 13 42, 15 40 C17 37, 19 34, 25 33 Z" fill="#FFD400"/>
          <path d="M37 27 C44 28, 50 32, 53 36 C55 39, 53 42, 50 41 C46 39, 43 35, 36 34 Z" fill="#FFD400"/>
          <path d="M26 41 C22 47, 19 52, 18 56 C18 59, 22 60, 24 57 C27 53, 30 48, 32 45 Z" fill="#FFD400"/>
          <path d="M34 41 C37 47, 41 52, 45 56 C47 58, 50 56, 49 53 C47 49, 43 45, 38 42 Z" fill="#FFD400"/>
        </svg>
      `;

      const bubble = document.createElement("div");
      bubble.className = "bubble";
      bubble.textContent = "smnth will be later here, now go away";

      el.appendChild(man);
      el.appendChild(bubble);
      document.body.appendChild(el);

      return { el, man, bubble };
    }

    function spawnMan(x, y) {
      if (men.length >= MAX_MEN) return;
      const { el, man, bubble } = makeRunnerElement();
      const m = {
        el, man, bubble,
        alive: true,
        pos: { x, y },
        vel: { x: 0, y: 0 },
        facing: 1,
        bobT: 0,
        stopUntil: 0,
        speakUntil: 0,
        lastSpeak: 0,
      };
      el.style.left = x + "px";
      el.style.top = y + "px";
      men.push(m);
    }

    function killMan(m) {
      if (!m.alive) return;
      m.alive = false;

      // trigger death animation
      m.el.classList.add("dead");

      // remove after transition
      setTimeout(() => {
        m.el.remove();
        const idx = men.indexOf(m);
        if (idx >= 0) men.splice(idx, 1);
      }, 260);
    }

    function explode(x, y) {
      // Visual explosion
      const ex = document.createElement("div");
      ex.className = "explosion";
      ex.style.left = x + "px";
      ex.style.top  = y + "px";

      for (let i = 0; i < EXPLOSION_DOTS; i++) {
        const d = document.createElement("div");
        d.className = "dot";
        const ang = (Math.PI * 2) * (i / EXPLOSION_DOTS);
        const r = 22 + Math.random() * 34;
        d.style.setProperty("--dx", `${Math.cos(ang) * r}px`);
        d.style.setProperty("--dy", `${Math.sin(ang) * r}px`);
        d.style.animationDuration = (480 + Math.random() * 220) + "ms";
        ex.appendChild(d);
      }

      document.body.appendChild(ex);
      setTimeout(() => ex.remove(), 750);

      // Kill in radius
      for (const m of [...men]) {
        if (!m.alive) continue;
        const dx = m.pos.x - x;
        const dy = m.pos.y - y;
        if (Math.hypot(dx, dy) <= EXPLOSION_RADIUS) killMan(m);
      }
    }

    // Mouse down:
    // - Right click => explode
    // - Left click => spawn a man (until 15) AND set target
    window.addEventListener("pointerdown", (e) => {
      if (e.button === 2) { // ПКМ
        e.preventDefault();
        explode(e.clientX, e.clientY);
        return;
      }
      // ЛКМ
      setTarget(e.clientX, e.clientY);
      spawnMan(e.clientX, e.clientY);
    }, { passive: false });

    // Seed one man when layout is ready
    function seed() {
      const r = note.getBoundingClientRect();
      const x = r.left + r.width * 0.25;
      const y = r.top + r.height * 0.55;
      spawnMan(x, y);

      // Default target (so it moves even before first mouse move)
      target.x = r.left + r.width * 0.75;
      target.y = r.top + r.height * 0.35;
    }

    // Start after DOM/layout is stable
    requestAnimationFrame(() => requestAnimationFrame(seed));

    // Loop
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

    function tick(now) {
      const dt = clamp(now - (tick._last || now), 8, 28);
      tick._last = now;

      // If no pointer yet, keep target in textarea area
      if (!hasPointer) {
        const r = note.getBoundingClientRect();
        target.x = r.left + r.width * 0.75;
        target.y = r.top + r.height * 0.35;
      }

      for (const m of men) {
        if (!m.alive) continue;

        const stopped = now < m.stopUntil;

        if (!stopped) {
          const dx = target.x - m.pos.x;
          const dy = target.y - m.pos.y;
          const dist = Math.hypot(dx, dy) || 1;

          if (Math.abs(dx) > 2) m.facing = dx >= 0 ? 1 : -1;

          const ax = (dx / dist) * CFG.accel * dt;
          const ay = (dy / dist) * CFG.accel * dt;

          m.vel.x = (m.vel.x + ax) * CFG.friction;
          m.vel.y = (m.vel.y + ay) * CFG.friction;

          const sp = Math.hypot(m.vel.x, m.vel.y) || 1;
          const maxV = CFG.maxSpeed * dt;
          if (sp > maxV) {
            m.vel.x = (m.vel.x / sp) * maxV;
            m.vel.y = (m.vel.y / sp) * maxV;
          }

          m.pos.x += m.vel.x;
          m.pos.y += m.vel.y;

          m.pos.x = clamp(m.pos.x, 0, window.innerWidth);
          m.pos.y = clamp(m.pos.y, 44, window.innerHeight); // below header

          // Catch
          if (dist < CFG.catchRadius) {
            m.pos.x = target.x;
            m.pos.y = target.y;
            m.vel.x = 0; m.vel.y = 0;
            m.stopUntil = now + CFG.stopMs;

            // Speak
            if (now - m.lastSpeak > CFG.speakCooldownMs) {
              m.lastSpeak = now;
              m.speakUntil = now + CFG.speakMs;
              m.bubble.classList.add("on");
            }
          }

          const speed01 = clamp(sp / (maxV + 1e-6), 0, 1);
          m.bobT += dt * 0.01 * (0.6 + speed01 * 2.0);
        }

        if (m.bubble.classList.contains("on") && now > m.speakUntil) {
          m.bubble.classList.remove("on");
        }

        const bob = Math.sin(m.bobT) * 1.0;
        m.el.style.left = m.pos.x + "px";
        m.el.style.top  = (m.pos.y + bob) + "px";
        m.man.style.transform = `scaleX(${m.facing})`;
      }

      requestAnimationFrame(tick);
    }

    requestAnimationFrame(tick);
  })();
  </script>
</body>
</html>
