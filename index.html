<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Minimal Bio + Notes</title>
  <style>
    :root { color-scheme: light; }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: #fff; color: #000; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; }

    /* Full-bleed white, no extra spaces */
    .wrap { height: 100%; width: 100%; display: grid; grid-template-rows: auto 1fr; }

    header{
      display:flex; align-items:baseline; justify-content:space-between;
      padding: 10px 12px;
      border-bottom: 1px solid rgba(0,0,0,0.10);
    }
    .name{ margin:0; font-size:16px; font-weight:650; letter-spacing:-0.2px; }
    .desc{ margin:2px 0 0; font-size:12px; color:rgba(0,0,0,0.60); }
    .meta{ font-size:12px; color:rgba(0,0,0,0.45); white-space:nowrap; }

    main{ position:relative; width:100%; height:100%; }

    /* Write field fills remaining area */
    .note{ position:absolute; inset:0; display:grid; grid-template-rows:auto 1fr auto; }
    .note label{
      padding:10px 12px;
      font-size:12px; color:rgba(0,0,0,0.55);
      display:flex; justify-content:space-between; align-items:center;
      border-bottom:1px solid rgba(0,0,0,0.08);
    }
    textarea{
      width:100%; height:100%;
      border:0; outline:none; resize:none;
      padding:14px 12px;
      font-size:15px; line-height:1.5;
      background:#fff; color:#000;
    }
    .hint{
      padding:10px 12px;
      font-size:12px; color:rgba(0,0,0,0.45);
      border-top:1px solid rgba(0,0,0,0.08);
      display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap;
    }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 11px;
      border: 1px solid rgba(0,0,0,0.14);
      background: rgba(0,0,0,0.03);
      padding: 2px 6px;
      border-radius: 8px;
    }

    /* Little man (non-pixel, simple silhouette like your example) */
    .runner{
      position:absolute;
      left:0; top:0;
      width: 54px; height: 54px; /* overall visual size */
      pointer-events:none;
      will-change: transform;
      transform: translate(-999px,-999px);
      filter: drop-shadow(0 10px 10px rgba(0,0,0,0.10));
    }

    .man svg { width: 54px; height: 54px; display:block; }

    /* Speech bubble */
    .bubble{
      position:absolute;
      left: 58px;
      top: -4px;
      max-width: 220px;
      padding: 8px 10px;
      border-radius: 14px;
      background: #fff;
      border: 1px solid rgba(0,0,0,0.14);
      color: rgba(0,0,0,0.80);
      font-size: 12px;
      line-height: 1.25;
      box-shadow: 0 12px 30px rgba(0,0,0,0.10);
      opacity: 0;
      transform: translateY(-6px);
      transition: opacity .16s ease, transform .16s ease;
      white-space: normal;
    }
    .bubble.on{
      opacity: 1;
      transform: translateY(0);
    }
    .bubble:after{
      content:"";
      position:absolute;
      left: -6px; top: 18px;
      width: 10px; height: 10px;
      background: #fff;
      border-left: 1px solid rgba(0,0,0,0.14);
      border-bottom: 1px solid rgba(0,0,0,0.14);
      transform: rotate(45deg);
    }

    @media (prefers-reduced-motion: reduce){
      .runner{ display:none; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <main>
      <div class="runner" id="runner" aria-hidden="true">
        <div class="man" id="man">
          <!-- Simple silhouette inspired by your example (no face) -->
          <svg viewBox="0 0 64 64" aria-hidden="true">
            <!-- head -->
            <circle cx="30" cy="14" r="9" fill="#FFD400"/>
            <!-- torso -->
            <path d="M24 24
                     C24 20, 36 20, 36 24
                     L38 40
                     C38 46, 22 46, 22 40
                     Z" fill="#FFD400"/>
            <!-- left arm -->
            <path d="M23 27
                     C16 28, 12 33, 11 37
                     C10 40, 13 42, 15 40
                     C17 37, 19 34, 25 33
                     Z" fill="#FFD400"/>
            <!-- right arm -->
            <path d="M37 27
                     C44 28, 50 32, 53 36
                     C55 39, 53 42, 50 41
                     C46 39, 43 35, 36 34
                     Z" fill="#FFD400"/>
            <!-- left leg -->
            <path d="M26 41
                     C22 47, 19 52, 18 56
                     C18 59, 22 60, 24 57
                     C27 53, 30 48, 32 45
                     Z" fill="#FFD400"/>
            <!-- right leg -->
            <path d="M34 41
                     C37 47, 41 52, 45 56
                     C47 58, 50 56, 49 53
                     C47 49, 43 45, 38 42
                     Z" fill="#FFD400"/>
          </svg>
        </div>

        <div class="bubble" id="bubble">smnth will be later here, now go away</div>
      </div>
    </main>
  </div>

<script>
(() => {
  const note = document.getElementById("note");
  const runner = document.getElementById("runner");
  const bubble = document.getElementById("bubble");

  // Focus shortcut
  window.addEventListener("keydown", (e) => {
    if (e.key.toLowerCase() === "k" && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      note.focus();
    }
  });

  const prefersReducedMotion = window.matchMedia?.("(prefers-reduced-motion: reduce)")?.matches;
  if (prefersReducedMotion) return;

  // Cursor target in viewport coords
  let target = { x: window.innerWidth * 0.65, y: window.innerHeight * 0.55 };
  let hasPointer = false;

  function setTarget(e){
    hasPointer = true;
    target.x = e.clientX;
    target.y = e.clientY;
  }
  window.addEventListener("pointermove", setTarget, { passive: true });
  window.addEventListener("pointerdown", setTarget, { passive: true });

  // Runner physics
  const pos = { x: window.innerWidth * 0.18, y: window.innerHeight * 0.6 };
  const vel = { x: 0, y: 0 };

  let paused = false;
  let fast = false;

  const cfg = {
    accel: 0.020,
    maxSpeed: 1.55,   // px/ms
    friction: 0.86,
    catchRadius: 12,
    stopMs: 260
  };

  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  // 2) Center-of-cursor fix:
  // We anchor runner using its visual center (width/2, height/2).
  // We'll apply translate(x - cx, y - cy).
  function getCenterOffset(){
    const r = runner.getBoundingClientRect();
    return { cx: r.width / 2, cy: r.height / 2 };
  }
  // Use constants (54px) to avoid layout reads each frame
  const CENTER = { cx: 54/2, cy: 54/2 };

  // 3) Show speech on catch, no other UI.
  let stopUntil = 0;
  let speakUntil = 0;
  let lastSpeak = 0;

  // Facing direction without rotation (head always up); only mirror left/right
  let facing = 1;

  // Minimal “walking” squish animation (optional, subtle)
  let bobT = 0;

  function step(now){
    const dt = clamp(now - (step._last || now), 8, 28);
    step._last = now;

    if (!hasPointer) {
      const r = note.getBoundingClientRect();
      target.x = r.left + r.width * 0.75;
      target.y = r.top + r.height * 0.35;
    }

    const speedMul = fast ? 1.9 : 1.0;
    const stopped = now < stopUntil;

    if (!paused && !stopped) {
      const dx = target.x - pos.x;
      const dy = target.y - pos.y;
      const dist = Math.hypot(dx, dy) || 1;

      // face by x only
      if (Math.abs(dx) > 2) facing = dx >= 0 ? 1 : -1;

      const ax = (dx / dist) * cfg.accel * dt * speedMul;
      const ay = (dy / dist) * cfg.accel * dt * speedMul;

      vel.x = (vel.x + ax) * cfg.friction;
      vel.y = (vel.y + ay) * cfg.friction;

      const sp = Math.hypot(vel.x, vel.y) || 1;
      const maxV = cfg.maxSpeed * dt * speedMul;
      if (sp > maxV) {
        vel.x = (vel.x / sp) * maxV;
        vel.y = (vel.y / sp) * maxV;
      }

      pos.x += vel.x;
      pos.y += vel.y;

      // keep inside viewport (with center accounted)
      pos.x = clamp(pos.x, CENTER.cx, window.innerWidth - CENTER.cx);
      pos.y = clamp(pos.y, CENTER.cy, window.innerHeight - CENTER.cy);

      // Catch: stop exactly on cursor center
      if (dist < cfg.catchRadius) {
        // snap center to cursor
        pos.x = target.x;
        pos.y = target.y;

        vel.x = 0; vel.y = 0;
        stopUntil = now + cfg.stopMs;

        // 3) show message on catch
        // show it briefly, but don't spam continuously while user stays still
        if (now - lastSpeak > 600) {
          lastSpeak = now;
          speakUntil = now + 1200;
          bubble.classList.add("on");
        }
      }

      // subtle walk bobbing
      bobT += dt * 0.01 * (0.6 + (Math.min(1, sp/(maxV+1e-6))) * 2.0);
    } else {
      // when stopped, keep bubble visibility timer running
    }

    // Hide bubble when time expires
    if (bubble.classList.contains("on") && now > speakUntil) {
      bubble.classList.remove("on");
    }

    const bob = Math.sin(bobT) * 1.0;
    // Render: translate to (pos - center), mirror via scaleX, NO rotation.
    runner.style.transform =
      `translate(${(pos.x - CENTER.cx)}px, ${(pos.y - CENTER.cy) + bob}px) scaleX(${facing})`;

    requestAnimationFrame(step);
  }

  window.addEventListener("keydown", (e) => {
    if (e.key === " ") { e.preventDefault(); paused = !paused; }
    if (e.key.toLowerCase() === "q") fast = !fast;
  });

  requestAnimationFrame(step);
})();
</script>
</body>
</html>
