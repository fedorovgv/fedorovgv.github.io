```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Minimal Bio + Notes</title>
  <style>
    :root { color-scheme: light; }
    * { box-sizing: border-box; }

    /* 1) Full-bleed pure white, no outer padding/margins */
    html, body { height: 100%; margin: 0; background: #fff; color: #000; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; }

    .wrap{
      height: 100%;
      width: 100%;
      display: grid;
      grid-template-rows: auto 1fr;
      /* no padding / no gaps => “no additional spaces” */
    }

    header{
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      padding: 10px 12px;
      border-bottom: 1px solid rgba(0,0,0,0.10);
    }

    .name{ margin: 0; font-size: 16px; font-weight: 650; letter-spacing: -0.2px; }
    .desc{ margin: 2px 0 0; font-size: 12px; color: rgba(0,0,0,0.60); }
    .meta{ font-size: 12px; color: rgba(0,0,0,0.45); white-space: nowrap; }

    main{
      position: relative;
      width: 100%;
      height: 100%;
    }

    /* Minimal write field, centered but with no “card” spacing/decoration */
    .note{
      position: absolute;
      inset: 0; /* fill entire remaining area */
      display: grid;
      grid-template-rows: auto 1fr auto;
    }

    .note label{
      padding: 10px 12px;
      font-size: 12px;
      color: rgba(0,0,0,0.55);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid rgba(0,0,0,0.08);
    }

    textarea{
      width: 100%;
      height: 100%;
      border: 0;
      outline: none;
      resize: none;
      padding: 14px 12px;
      font-size: 15px;
      line-height: 1.5;
      background: #fff;
      color: #000;
    }

    .hint{
      padding: 10px 12px;
      font-size: 12px;
      color: rgba(0,0,0,0.45);
      border-top: 1px solid rgba(0,0,0,0.08);
      display: flex;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }

    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 11px;
      border: 1px solid rgba(0,0,0,0.14);
      background: rgba(0,0,0,0.03);
      padding: 2px 6px;
      border-radius: 8px;
    }

    /* 2) Pixel sprite runner */
    .runner{
      position: absolute;
      left: 0; top: 0;
      width: 64px; height: 64px;
      transform: translate(-200px, -200px);
      pointer-events: none;
      will-change: transform;
    }

    /* Pixel look: nearest-neighbor scaling */
    .runner canvas{
      width: 64px; height: 64px;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      display: block;
    }

    /* Small “tag” popup */
    .bubble{
      position: absolute;
      left: 62px; top: 2px;
      padding: 4px 6px;
      border-radius: 10px;
      font-size: 12px;
      background: #fff;
      border: 1px solid rgba(0,0,0,0.12);
      color: rgba(0,0,0,0.65);
      transform: translateY(-6px);
      opacity: 0;
      transition: opacity .18s ease, transform .18s ease;
      white-space: nowrap;
    }
    .bubble.on{ opacity: 1; transform: translateY(0); }

    @media (prefers-reduced-motion: reduce){
      .runner{ display:none; }
    }
  </style>
</head>

<body>
  <div class="wrap" id="stage">
    <header>
      <div>
        <h1 class="name">Alex — Portfolio</h1>
        <p class="desc">ML / DL engineer • Speech & neural networks</p>
      </div>
      <div class="meta">github.io</div>
    </header>

    <main>
      <section class="note">
        <label>
          <span>Write</span>
          <span class="kbd">Ctrl/⌘ + K</span>
        </label>

        <textarea id="note" placeholder="Type here…"></textarea>

        <div class="hint">
          <span>Move cursor — pixel dude tries to catch it.</span>
          <span><span class="kbd">Q</span> speed • <span class="kbd">Space</span> pause</span>
        </div>
      </section>

      <div class="runner" id="runner" aria-hidden="true">
        <canvas id="sprite" width="16" height="16"></canvas>
        <div class="bubble" id="bubble">tag!</div>
      </div>
    </main>
  </div>

<script>
(() => {
  const note = document.getElementById("note");
  const runner = document.getElementById("runner");
  const bubble = document.getElementById("bubble");
  const c = document.getElementById("sprite");
  const ctx = c.getContext("2d", { alpha: true });

  // Shortcut focus
  window.addEventListener("keydown", (e) => {
    if (e.key.toLowerCase() === "k" && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      note.focus();
    }
  });

  const prefersReducedMotion = window.matchMedia?.("(prefers-reduced-motion: reduce)")?.matches;
  if (prefersReducedMotion) return;

  // Target (cursor)
  let target = { x: window.innerWidth * 0.65, y: window.innerHeight * 0.55 };
  let hasPointer = false;

  function setTarget(e){
    hasPointer = true;
    target.x = e.clientX;
    target.y = e.clientY;
  }
  window.addEventListener("pointermove", setTarget, { passive: true });
  window.addEventListener("pointerdown", setTarget, { passive: true });

  // Runner physics
  const pos = { x: window.innerWidth * 0.18, y: window.innerHeight * 0.6 };
  const vel = { x: 0, y: 0 };

  let paused = false;
  let fast = false;

  const cfg = {
    accel: 0.018,
    maxSpeed: 1.35,    // px/ms
    friction: 0.86,
    catchRadius: 16,
    overshoot: 10
  };

  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  // 3) Prevent turning over: we NEVER rotate the sprite.
  // We only mirror left/right (scaleX) and keep head "up".
  let facing = 1; // 1 right, -1 left

  // --- 2) Pixel sprite drawing (16x16) ---
  // Two-frame run cycle + idle. We'll draw into 16x16 and scale up via CSS.
  function px(x,y,color){
    ctx.fillStyle = color;
    ctx.fillRect(x, y, 1, 1);
  }

  function clear(){
    ctx.clearRect(0,0,16,16);
  }

  function drawSprite(frame, speed01){
    clear();

    // Palette
    const Y = "#FFD400";           // body
    const Y2 = "#F2C200";          // shadow
    const O = "rgba(0,0,0,0.12)";  // outline-ish
    const D = "rgba(0,0,0,0.35)";  // darker detail

    // Slight bob based on speed
    const bob = Math.round((Math.sin(frame.t * 0.9) * 0.6) * speed01);

    // Pixel “person” base origin
    const ox = 5;
    const oy = 2 + bob;

    // Head (always up)
    // outline ring
    for (let yy=0; yy<4; yy++){
      for (let xx=0; xx<4; xx++){
        const edge = (xx===0||xx===3||yy===0||yy===3);
        px(ox+xx, oy+yy, edge ? O : Y);
      }
    }
    // Eye
    px(ox+2, oy+2, D);

    // Body (torso)
    for (let yy=0; yy<5; yy++){
      for (let xx=0; xx<4; xx++){
        const edge = (xx===0||xx===3||yy===0||yy===4);
        px(ox+xx, oy+4+yy, edge ? O : Y);
      }
    }
    // Belt/shadow line
    px(ox+1, oy+7, Y2); px(ox+2, oy+7, Y2);

    // Arms (swing)
    const armUp = (frame.i % 2 === 0);
    if (armUp) {
      px(ox-1, oy+6, O); px(ox-2, oy+5, Y);
      px(ox+4, oy+6, O); px(ox+5, oy+5, Y);
    } else {
      px(ox-1, oy+7, O); px(ox-2, oy+8, Y);
      px(ox+4, oy+7, O); px(ox+5, oy+8, Y);
    }

    // Legs (run cycle)
    // Frame 0: left forward, right back
    // Frame 1: right forward, left back
    const leftForward = (frame.i % 2 === 0);

    // hip anchors
    const hxL = ox+1, hxR = ox+2, hy = oy+9;

    function leg(x, y, forward){
      // upper
      px(x, y, O);
      px(x, y+1, Y);
      // lower
      if (forward){
        px(x+1, y+2, Y);
        px(x+2, y+3, O);
        px(x+3, y+3, Y);
      } else {
        px(x-1, y+2, Y2);
        px(x-2, y+3, O);
        px(x-3, y+3, Y2);
      }
      // foot
      if (forward) {
        px(x+3, y+4, O); px(x+4, y+4, Y);
      } else {
        px(x-3, y+4, O); px(x-4, y+4, Y2);
      }
    }

    leg(hxL, hy, leftForward);
    leg(hxR, hy, !leftForward);

    // Small “dust” pixel when moving
    if (speed01 > 0.35) {
      const dx = leftForward ? 2 : 1;
      px(ox-4, oy+13, "rgba(0,0,0,0.06)");
      px(ox-5, oy+14, "rgba(0,0,0,0.05)");
      px(ox-3, oy+14, "rgba(0,0,0,0.04)");
      px(ox-2, oy+13, "rgba(0,0,0,0.04)");
    }
  }

  // Animation state for sprite
  const spriteState = { t: 0, i: 0, accum: 0 };

  let last = performance.now();
  let lastCatch = 0;

  function step(now){
    const dt = clamp(now - last, 8, 28);
    last = now;

    if (!hasPointer) {
      const r = note.getBoundingClientRect();
      target.x = r.left + r.width * 0.75;
      target.y = r.top + r.height * 0.35;
    }

    const speedMul = fast ? 1.9 : 1.0;

    if (!paused) {
      const dx = target.x - pos.x;
      const dy = target.y - pos.y;
      const dist = Math.hypot(dx, dy) || 1;

      // Set facing by x only (no rotation)
      if (Math.abs(dx) > 2) facing = dx >= 0 ? 1 : -1;

      const ax = (dx / dist) * cfg.accel * dt * speedMul;
      const ay = (dy / dist) * cfg.accel * dt * speedMul;

      vel.x = (vel.x + ax) * cfg.friction;
      vel.y = (vel.y + ay) * cfg.friction;

      const sp = Math.hypot(vel.x, vel.y) || 1;
      const maxV = cfg.maxSpeed * dt * speedMul;
      if (sp > maxV) {
        vel.x = (vel.x / sp) * maxV;
        vel.y = (vel.y / sp) * maxV;
      }

      pos.x += vel.x;
      pos.y += vel.y;

      // Keep on screen
      pos.x = clamp(pos.x, 8, window.innerWidth - 8);
      pos.y = clamp(pos.y, 8, window.innerHeight - 8);

      // Catch
      if (dist < cfg.catchRadius && (now - lastCatch) > 450) {
        lastCatch = now;
        bubble.classList.add("on");
        setTimeout(() => bubble.classList.remove("on"), 380);

        // slight overshoot/back-off so it “tags” then continues
        pos.x -= (dx / dist) * cfg.overshoot;
        pos.y -= (dy / dist) * cfg.overshoot;
      }

      // Sprite timing based on speed
      const speed01 = clamp(sp / (maxV + 1e-6), 0, 1);
      spriteState.t += dt * 0.01 * (0.6 + speed01 * 2.2);
      spriteState.accum += dt * (0.002 + speed01 * 0.010);
      if (spriteState.accum > 1) {
        spriteState.i = (spriteState.i + 1) % 2;
        spriteState.accum = 0;
      }

      drawSprite(spriteState, speed01);

      // Render: translate + mirror only (NO rotation), head always up
      runner.style.transform = `translate(${pos.x}px, ${pos.y}px) scaleX(${facing})`;
    } else {
      // paused: still draw idle
      drawSprite({ t: spriteState.t, i: 0 }, 0);
      runner.style.transform = `translate(${pos.x}px, ${pos.y}px) scaleX(${facing})`;
    }

    requestAnimationFrame(step);
  }

  // Controls
  window.addEventListener("keydown", (e) => {
    if (e.key === " ") { e.preventDefault(); paused = !paused; }
    if (e.key.toLowerCase() === "q") fast = !fast;
  });

  // First render
  drawSprite({ t: 0, i: 0 }, 0);
  requestAnimationFrame(step);
})();
</script>
</body>
</html>
```

