<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DL engineer</title>
  <style>
    *{ box-sizing:border-box; }
    html,body{ height:100%; margin:0; background:#fff; overflow:hidden; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; }

    header{
      position:fixed; left:0; right:0; top:0;
      height:44px; display:flex; align-items:center;
      padding:0 14px; font-size:14px; font-weight:650;
      border-bottom:1px solid rgba(0,0,0,0.10);
      background:#fff; user-select:none; z-index:10;
    }

    /* FX canvas: transparent overlay */
    #fx{
      position:fixed; inset:0;
      width:100vw; height:100vh;
      pointer-events:none;
      z-index:2000; /* above men, but transparent */
    }

    .runner{
      position:fixed; left:0; top:0;
      width:54px; height:54px;
      transform:translate(-50%,-50%);
      pointer-events:none;
      z-index:1000;
      filter:drop-shadow(0 10px 12px rgba(0,0,0,0.10));
      will-change:left,top;
    }

    .man{ width:54px; height:54px; transform-origin:50% 50%; will-change:transform; }
    .man svg{ width:54px; height:54px; display:block; }

    .bubble{
      position:absolute;
      left:62px; top:-4px;
      max-width:320px;
      padding:8px 10px;
      border-radius:14px;
      background:#fff;
      border:1px solid rgba(0,0,0,0.14);
      color:rgba(0,0,0,0.80);
      font-size:12px;
      line-height:1.25;
      box-shadow:0 12px 30px rgba(0,0,0,0.10);
      opacity:0;
      transform:translateY(-6px);
      transition:opacity .16s ease, transform .16s ease;
      white-space:normal;
      pointer-events:none;
    }
    .bubble.on{ opacity:1; transform:translateY(0); }
    .bubble:after{
      content:"";
      position:absolute;
      left:-6px; top:18px;
      width:10px; height:10px;
      background:#fff;
      border-left:1px solid rgba(0,0,0,0.14);
      border-bottom:1px solid rgba(0,0,0,0.14);
      transform:rotate(45deg);
    }

    .corpse{
      position:fixed; left:0; top:0;
      width:54px; height:54px;
      transform:translate(-50%,-50%);
      pointer-events:none;
      z-index:1400;
      filter:drop-shadow(0 12px 18px rgba(0,0,0,0.10));
      opacity:1;
      will-change:left,top,opacity,transform;
    }
    .corpse svg{ width:54px; height:54px; display:block; }
    .corpse.fade{
      opacity:0;
      transition:opacity 520ms ease;
    }

    /* SOUL: monotone grey + X eyes, no glow */
    .soul{
      position:fixed; left:0; top:0;
      width:64px; height:64px;
      transform:translate(-50%,-50%);
      pointer-events:none;
      z-index:1500;
      opacity:0;
      filter:drop-shadow(0 10px 18px rgba(0,0,0,0.10));
      will-change:left,top,opacity;
    }
    .soul svg{ width:64px; height:64px; display:block; }
    .soul.on{ opacity:1; transition:opacity 200ms ease; }
  </style>
</head>
<body>
  <header> Fedorov Grigory | DL engineer | Pretrain Infra </header>
  <canvas id="fx"></canvas>

<script>
(() => {
  const DESIRED_MEN = 10;
  const MAX_MEN = 10;
  const EXPLOSION_RADIUS = 170;
  const HEADER_H = 44;

  const CFG = {
    accel: 0.020,
    maxSpeed: 1.70,
    friction: 0.86,
    catchRadius: 14,
    stopMs: 240,
    speakMs: 1300,
    speakCooldownMs: 650,
  };

  // gather around cursor in a circle
  const ORBIT = { r: 56, jitter: 10 };

  const SOUL = {
    risePxPerMs: 0.16,   // slower (more visible)
    lifeMs: 6200,        // longer
    driftX: 240,
    waveAmp: [28, 46],
    waveFreq: [0.005, 0.009],
    fadeStart: 2600,
  };

  addEventListener("contextmenu", (e) => e.preventDefault());

  let target = { x: innerWidth * 0.6, y: innerHeight * 0.6 };
  let hasPointer = false;
  function setTarget(x, y){ hasPointer = true; target.x = x; target.y = y; }
  addEventListener("pointermove", (e) => setTarget(e.clientX, e.clientY), { passive: true });

  const men = [];

  function baseManSVG({ color, outline, deadEyes }) {
    const fill = color;
    const out = outline ? "rgba(0,0,0,0.30)" : "none";
    const outW = outline ? 2.2 : 0;

    const LIMB = 6.0;
    const THIGH = 7.0;
    const NECK = 3.2;

    const KNEE_CAP_W = 7.4;
    const KNEE_CAP_H = 5.0;

    const eyes = deadEyes ? `
      <g stroke="rgba(0,0,0,0.65)" stroke-width="1.6" stroke-linecap="round">
        <path d="M28.1 12.0 L30.7 14.6" />
        <path d="M30.7 12.0 L28.1 14.6" />
        <path d="M33.3 12.0 L35.9 14.6" />
        <path d="M35.9 12.0 L33.3 14.6" />
      </g>
    ` : "";

    return `
      <svg viewBox="0 0 64 78" aria-hidden="true">
        <g stroke="${out}" stroke-width="${outW}" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="32" cy="13.5" r="9.3" fill="${fill}" />
          ${eyes}

          <path d="M32 21 L32 29" stroke="${fill}" stroke-width="${NECK}" />
          <ellipse cx="32" cy="38" rx="8.9" ry="14.5" fill="${fill}" />

          <path d="M24 30 L12 38" stroke="${fill}" stroke-width="${LIMB}" />
          <path d="M40 30 L52 38" stroke="${fill}" stroke-width="${LIMB}" />

          <ellipse cx="32" cy="48" rx="8.2" ry="6.0" fill="${fill}" />

          <path d="M29 48 L23 61" stroke="${fill}" stroke-width="${THIGH}" />
          <path d="M35 48 L41 61" stroke="${fill}" stroke-width="${THIGH}" />

          <g class="shinL">
            <path d="M23 61 L30 76" stroke="${fill}" stroke-width="${LIMB}" />
          </g>
          <g class="shinR">
            <path d="M41 61 L34 76" stroke="${fill}" stroke-width="${LIMB}" />
          </g>

          <rect x="19.5" y="58.7" width="${KNEE_CAP_W}" height="${KNEE_CAP_H}" rx="3.2" fill="${fill}" />
          <rect x="37.1" y="58.7" width="${KNEE_CAP_W}" height="${KNEE_CAP_H}" rx="3.2" fill="${fill}" />
        </g>
      </svg>
    `;
  }

  function aliveSVG(){ return baseManSVG({ color:"#FFD400", outline:false, deadEyes:false }); }
  function soulSVG(){  return baseManSVG({ color:"#CFCFCF", outline:false, deadEyes:true  }); }
  function corpseSVG(){return baseManSVG({ color:"#F2F2F2", outline:false, deadEyes:true  }); }

  function makeRunnerElement(){
    const el = document.createElement("div");
    el.className = "runner";

    const man = document.createElement("div");
    man.className = "man";
    man.innerHTML = aliveSVG();

    const bubble = document.createElement("div");
    bubble.className = "bubble";
    bubble.textContent = "there will be smthng here! but for now - go away!";

    el.appendChild(man);
    el.appendChild(bubble);
    document.body.appendChild(el);

    const svg = man.querySelector("svg");
    const parts = {
      shinL: svg.querySelector(".shinL"),
      shinR: svg.querySelector(".shinR"),
    };
    return { el, man, bubble, parts };
  }

  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function rand(a,b){ return a + Math.random()*(b-a); }

  function randomSpawnPoint(){
    const pad = 26;
    const x = rand(pad, innerWidth - pad);
    const y = rand(HEADER_H + pad, innerHeight - pad);
    return { x, y };
  }

  function reassignOrbitSlots(){
    const orbiters = men.filter(m => m.alive && m.orbitAngle !== null);
    const n = orbiters.length;
    if (n === 0) return;
    const offset = (performance.now() * 0.00035) % (Math.PI * 2);
    for (let i = 0; i < n; i++) {
      orbiters[i].orbitAngle = offset + i * (Math.PI * 2 / n);
    }
  }

  function maintainPopulation(){
    while (men.length < DESIRED_MEN) {
      const p = randomSpawnPoint();
      spawnMan(p.x, p.y);
    }
  }

  function spawnMan(x, y){
    if (men.length >= MAX_MEN) return;
    y = clamp(y, HEADER_H, innerHeight);

    const { el, man, bubble, parts } = makeRunnerElement();
    const m = {
      el, man, bubble, parts,
      alive: true,
      pos: { x, y },
      vel: { x: 0, y: 0 },
      facing: 1,
      bobT: 0,
      phase: Math.random() * Math.PI * 2,
      stopUntil: 0,
      speakUntil: 0,
      lastSpeak: 0,
      orbitAngle: null,
      orbitRadius: ORBIT.r + (Math.random() - 0.5) * ORBIT.jitter,
    };

    el.style.left = x + "px";
    el.style.top  = y + "px";

    men.push(m);
    reassignOrbitSlots();
    applyPose(m, 0, 0);
  }

  function spawnCorpse(x, y, facing){
    const c = document.createElement("div");
    c.className = "corpse";
    c.style.left = x + "px";
    c.style.top  = y + "px";
    c.innerHTML = corpseSVG();

    const tilt = (Math.random() * 16 - 8);
    c.style.transform = `translate(-50%,-50%) rotate(${tilt}deg)`;

    const svg = c.querySelector("svg");
    svg.style.transformOrigin = "50% 50%";
    svg.style.transform = `scaleX(${facing})`;

    document.body.appendChild(c);

    setTimeout(() => c.classList.add("fade"), 520);
    setTimeout(() => c.remove(), 1100);
  }

  function spawnSoul(fromX, fromY, facing){
    const s = document.createElement("div");
    s.className = "soul";
    s.style.left = fromX + "px";
    s.style.top  = fromY + "px";
    s.innerHTML = soulSVG();
    document.body.appendChild(s);

    const svg = s.querySelector("svg");
    svg.style.transformOrigin = "50% 50%";
    svg.style.transform = `scaleX(${facing})`;

    requestAnimationFrame(() => s.classList.add("on"));

    const driftX = (Math.random() - 0.5) * SOUL.driftX;
    const waveA  = SOUL.waveAmp[0] + Math.random() * (SOUL.waveAmp[1] - SOUL.waveAmp[0]);
    const waveF  = SOUL.waveFreq[0] + Math.random() * (SOUL.waveFreq[1] - SOUL.waveFreq[0]);
    const rise   = SOUL.risePxPerMs * (0.9 + Math.random() * 0.25);
    const lifeMs = SOUL.lifeMs * (0.9 + Math.random() * 0.2);

    let t0 = null;
    const x0 = fromX, y0 = fromY;

    function step(ts){
      if (t0 === null) t0 = ts;
      const u = ts - t0;

      const nx = x0 + (driftX * (u / lifeMs)) + Math.sin(u * waveF) * waveA;
      const ny = y0 - (u * rise);

      s.style.left = nx + "px";
      s.style.top  = ny + "px";

      const fadeU = Math.max(0, u - SOUL.fadeStart);
      const alpha = Math.max(0, 1.0 - (fadeU / (lifeMs - SOUL.fadeStart)));
      s.style.opacity = alpha.toFixed(3);

      if (ny < -110 || u >= lifeMs || alpha <= 0.01) {
        s.remove();
        return;
      }
      requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
  }

  function killMan(m){
    if (!m.alive) return;

    const x = m.pos.x, y = m.pos.y, facing = m.facing;
    m.alive = false;

    const idx = men.indexOf(m);
    if (idx >= 0) men.splice(idx, 1);

    try { m.el.remove(); } catch {}

    spawnCorpse(x, y, facing);
    setTimeout(() => spawnSoul(x, y, facing), 90);

    reassignOrbitSlots();
    maintainPopulation();
  }

  // ===== shins animation only =====
  const KNEE_L = [23, 61];
  const KNEE_R = [41, 61];
  function rot(angleDeg, cx, cy){ return `rotate(${angleDeg.toFixed(2)} ${cx} ${cy})`; }

  function applyPose(m, speedPerMs, dt){
    const moving = speedPerMs > 0.08 && dt > 0;
    const freq = moving ? (7.2 + speedPerMs * 8.0) : 1.6;
    if (dt) m.phase += (dt / 1000) * freq;

    const s = Math.sin(m.phase);
    const base = 6;
    const amp  = moving ? 14 : 5;

    m.parts.shinL.setAttribute("transform", rot(base + amp * s, ...KNEE_L));
    m.parts.shinR.setAttribute("transform", rot(base - amp * s, ...KNEE_R));
  }

  // ===== Naturalistic explosion on canvas (FIXED: no white overlay) =====
  const fx = document.getElementById("fx");
  const ctx = fx.getContext("2d", { alpha:true });

  function resizeFx(){
    const dpr = Math.max(1, Math.min(2, devicePixelRatio || 1));
    fx.width = Math.floor(innerWidth * dpr);
    fx.height = Math.floor(innerHeight * dpr);
    fx.style.width = innerWidth + "px";
    fx.style.height = innerHeight + "px";
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.clearRect(0,0,innerWidth,innerHeight);
  }
  resizeFx();
  addEventListener("resize", resizeFx);

  const explosions = [];

  function addExplosion(x,y){
    const e = { x,y, t:0, life:1100, fire:[], smoke:[], sparks:[], shock:{ r:6, a:0.55 } };

    const fireN = 110;
    for (let i=0;i<fireN;i++){
      const ang = rand(0, Math.PI*2);
      const sp  = rand(0.5, 4.6) * (0.65 + Math.random()*0.6);
      const up  = rand(-1.2, -4.0);
      e.fire.push({
        x: x + rand(-3,3), y: y + rand(-3,3),
        vx: Math.cos(ang)*sp, vy: Math.sin(ang)*sp + up,
        r: rand(10, 26), life: rand(320, 680), age:0,
        wob: rand(0, 10),
      });
    }

    const smokeN = 70;
    for (let i=0;i<smokeN;i++){
      const ang = rand(0, Math.PI*2);
      const sp  = rand(0.2, 2.0);
      e.smoke.push({
        x: x + rand(-6,6), y: y + rand(-6,6),
        vx: Math.cos(ang)*sp, vy: Math.sin(ang)*sp + rand(-2.2, -0.6),
        r: rand(18, 44), life: rand(700, 1200), age:0,
        dens: rand(0.10, 0.22), swirl: rand(0.004, 0.012),
      });
    }

    const sparkN = 45;
    for (let i=0;i<sparkN;i++){
      const ang = rand(0, Math.PI*2);
      const sp  = rand(3.0, 8.8);
      e.sparks.push({
        x,y,
        vx: Math.cos(ang)*sp, vy: Math.sin(ang)*sp + rand(-1.5, 0.5),
        life: rand(220, 520), age:0,
        w: rand(1.0, 1.8), l: rand(10, 22),
      });
    }

    explosions.push(e);
  }

  function drawExplosion(e, dt){
    e.t += dt;

    e.shock.r += dt * 0.28;
    e.shock.a -= dt * 0.00075;

    // smoke
    ctx.save();
    ctx.globalCompositeOperation = "source-over";
    for (const s of e.smoke){
      s.age += dt;
      const u = s.age / s.life;
      if (u >= 1) continue;

      const swirl = Math.sin((e.t + s.age) * s.swirl * 12) * 0.18;
      s.vx += swirl * dt * 0.002;
      s.vy += (-0.0006) * dt;

      s.x += s.vx * dt * 0.06;
      s.y += s.vy * dt * 0.06;

      const r = s.r * (0.75 + u * 1.4);
      const a = s.dens * (1 - u);

      const g = ctx.createRadialGradient(s.x - r*0.2, s.y - r*0.2, r*0.2, s.x, s.y, r);
      g.addColorStop(0, `rgba(40,40,40,${a*0.9})`);
      g.addColorStop(0.5, `rgba(55,55,55,${a*0.6})`);
      g.addColorStop(1, `rgba(55,55,55,0)`);
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(s.x, s.y, r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();

    // fire
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    for (const p of e.fire){
      p.age += dt;
      const u = p.age / p.life;
      if (u >= 1) continue;

      const wob = Math.sin((p.age + p.wob) * 0.02) * 0.05;
      p.vx *= (1 - dt*0.0012);
      p.vy *= (1 - dt*0.0010);
      p.vy += 0.0022 * dt;
      p.vx += wob * dt * 0.03;

      p.x += p.vx * dt * 0.08;
      p.y += p.vy * dt * 0.08;

      const rr = p.r * (0.7 + (1-u)*0.9);
      const a = (1 - u) * 0.65;

      const g = ctx.createRadialGradient(p.x - rr*0.25, p.y - rr*0.25, rr*0.18, p.x, p.y, rr);
      g.addColorStop(0, `rgba(255,255,255,${a*0.95})`);
      g.addColorStop(0.18, `rgba(255,235,160,${a*0.95})`);
      g.addColorStop(0.45, `rgba(255,155,40,${a*0.85})`);
      g.addColorStop(0.78, `rgba(255,70,0,${a*0.55})`);
      g.addColorStop(1, `rgba(60,20,0,0)`);
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(p.x, p.y, rr, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();

    // sparks
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    for (const sp of e.sparks){
      sp.age += dt;
      const u = sp.age / sp.life;
      if (u >= 1) continue;

      sp.vx *= (1 - dt*0.0016);
      sp.vy *= (1 - dt*0.0012);
      sp.vy += 0.0030 * dt;
      sp.x += sp.vx * dt * 0.12;
      sp.y += sp.vy * dt * 0.12;

      const a = (1-u) * 0.75;
      ctx.strokeStyle = `rgba(255,200,120,${a})`;
      ctx.lineWidth = sp.w;

      const nx = sp.x - sp.vx * sp.l * 0.05;
      const ny = sp.y - sp.vy * sp.l * 0.05;
      ctx.beginPath();
      ctx.moveTo(nx, ny);
      ctx.lineTo(sp.x, sp.y);
      ctx.stroke();
    }
    ctx.restore();

    // shock ring
    if (e.shock.a > 0) {
      ctx.save();
      ctx.globalCompositeOperation = "source-over";
      ctx.strokeStyle = `rgba(255,120,40,${Math.max(0, e.shock.a)})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.shock.r, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }

    return e.t >= e.life;
  }

  let lastFx = performance.now();
  function fxLoop(now){
    const dt = Math.min(32, Math.max(8, now - lastFx));
    lastFx = now;

    // âœ… FIX: fade previous pixels by erasing them (keeps canvas transparent!)
    ctx.save();
    ctx.globalCompositeOperation = "destination-out";
    ctx.fillStyle = "rgba(0,0,0,0.18)";  // higher -> faster fade
    ctx.fillRect(0, 0, innerWidth, innerHeight);
    ctx.restore();

    for (let i = explosions.length - 1; i >= 0; i--){
      const done = drawExplosion(explosions[i], dt);
      if (done) explosions.splice(i, 1);
    }

    requestAnimationFrame(fxLoop);
  }
  requestAnimationFrame(fxLoop);

  function explode(x, y){
    addExplosion(x, y);

    const snapshot = [...men];
    for (const m of snapshot) {
      if (!m.alive) continue;
      const dx = m.pos.x - x;
      const dy = m.pos.y - y;
      if (Math.hypot(dx, dy) <= EXPLOSION_RADIUS) killMan(m);
    }
  }

  addEventListener("pointerdown", (e) => {
    if (e.button === 2) {
      e.preventDefault();
      explode(e.clientX, e.clientY);
    }
  }, { passive: false });

  function init(){
    for (let i = 0; i < DESIRED_MEN; i++) {
      const p = randomSpawnPoint();
      spawnMan(p.x, p.y);
    }
    maintainPopulation();
  }
  requestAnimationFrame(() => requestAnimationFrame(init));

  function clampDt(v){ return Math.max(8, Math.min(28, v)); }

  function tick(now){
    const dt = clampDt(now - (tick._last || now));
    tick._last = now;

    if (!hasPointer) { target.x = innerWidth * 0.70; target.y = innerHeight * 0.44; }

    for (const m of men) {
      if (!m.alive) continue;

      const stopped = now < m.stopUntil;

      let tx = target.x;
      let ty = target.y;
      if (m.orbitAngle !== null) {
        tx = target.x + Math.cos(m.orbitAngle) * m.orbitRadius;
        ty = target.y + Math.sin(m.orbitAngle) * m.orbitRadius;
      }
      ty = clamp(ty, HEADER_H, innerHeight);

      if (!stopped) {
        const dx = tx - m.pos.x;
        const dy = ty - m.pos.y;
        const dist = Math.hypot(dx, dy) || 1;

        if (Math.abs(dx) > 2) m.facing = dx >= 0 ? 1 : -1;

        const ax = (dx / dist) * CFG.accel * dt;
        const ay = (dy / dist) * CFG.accel * dt;

        m.vel.x = (m.vel.x + ax) * CFG.friction;
        m.vel.y = (m.vel.y + ay) * CFG.friction;

        const sp = Math.hypot(m.vel.x, m.vel.y) || 1;
        const maxV = CFG.maxSpeed * dt;
        if (sp > maxV) {
          m.vel.x = (m.vel.x / sp) * maxV;
          m.vel.y = (m.vel.y / sp) * maxV;
        }

        m.pos.x += m.vel.x;
        m.pos.y += m.vel.y;

        m.pos.x = clamp(m.pos.x, 0, innerWidth);
        m.pos.y = clamp(m.pos.y, HEADER_H, innerHeight);

        const distToCursor = Math.hypot(target.x - m.pos.x, target.y - m.pos.y);
        if (distToCursor < CFG.catchRadius) {
          if (m.orbitAngle === null) {
            m.orbitAngle = 0;
            reassignOrbitSlots();
          }
          const ox = target.x + Math.cos(m.orbitAngle) * m.orbitRadius;
          const oy = clamp(target.y + Math.sin(m.orbitAngle) * m.orbitRadius, HEADER_H, innerHeight);

          m.pos.x = ox;
          m.pos.y = oy;
          m.vel.x = 0; m.vel.y = 0;
          m.stopUntil = now + CFG.stopMs;

          if (now - m.lastSpeak > CFG.speakCooldownMs) {
            m.lastSpeak = now;
            m.speakUntil = now + CFG.speakMs;
            m.bubble.classList.add("on");
          }
        }
      }

      if (m.bubble.classList.contains("on") && now > m.speakUntil) {
        m.bubble.classList.remove("on");
      }

      const speedNow = Math.hypot(m.vel.x, m.vel.y);
      const speedPerMs = speedNow / dt;

      applyPose(m, speedPerMs, dt);

      const moving = !stopped && speedPerMs > 0.08;
      m.bobT += dt * 0.01 * (moving ? 1.2 : 0.6);
      const bob = Math.sin(m.bobT) * (moving ? 0.45 : 0.16);

      m.el.style.left = m.pos.x + "px";
      m.el.style.top  = (m.pos.y + bob) + "px";
      m.man.style.transform = `scaleX(${m.facing})`;
    }

    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  addEventListener("resize", () => {
    for (const m of men) {
      m.pos.x = clamp(m.pos.x, 0, innerWidth);
      m.pos.y = clamp(m.pos.y, HEADER_H, innerHeight);
    }
  });
})();
</script>
</body>
</html>
