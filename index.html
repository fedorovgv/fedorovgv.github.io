<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DL engineer</title>
  <style>
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: #fff; overflow: hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }

    header{
      position: fixed;
      left: 0; right: 0; top: 0;
      height: 44px;
      display: flex;
      align-items: center;
      padding: 0 14px;
      font-size: 14px;
      font-weight: 650;
      border-bottom: 1px solid rgba(0,0,0,0.10);
      background: #fff;
      user-select: none;
      z-index: 10;
    }

    /* --- Little man container --- */
    .runner{
      position: fixed;
      left: 0; top: 0;
      width: 86px; height: 86px;              /* bigger so leg motion is visible */
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 1000;
      filter: drop-shadow(0 10px 10px rgba(0,0,0,0.10));
      will-change: left, top;
    }

    .man{
      width: 86px; height: 86px;
      transform-origin: 50% 50%;
      transform: scaleX(1);
      will-change: transform, opacity;
    }
    .man svg { width: 86px; height: 86px; display: block; }

    /* death: yellow disappears quickly */
    .runner.dying .man{
      opacity: 0;
      transform: scaleX(var(--face, 1)) scale(0.92);
      transition: opacity 140ms ease, transform 180ms ease;
    }

    /* --- Running animation control --- */
    .runner .anim {
      animation-duration: var(--runDur, 420ms);
      animation-timing-function: ease-in-out;
      animation-iteration-count: infinite;
      animation-direction: alternate;
      animation-play-state: paused; /* only when moving */
    }
    .runner.moving .anim { animation-play-state: running; }

    /* swing + knee bend */
    .thighL { animation-name: thighL; }
    .thighR { animation-name: thighR; }

    .shinL  { animation-name: shinL;  }
    .shinR  { animation-name: shinR;  }

    .armL   { animation-name: armL;   }
    .armR   { animation-name: armR;   }

    /* opposite phase */
    .thighR, .shinR, .armR { animation-delay: calc(var(--runDur, 420ms) * -0.5); }

    /* Make transforms behave predictably on SVG groups */
    svg g { transform-box: fill-box; transform-origin: 50% 15%; }

    @keyframes thighL { 0% { transform: rotate(-22deg); } 100% { transform: rotate(18deg); } }
    @keyframes thighR { 0% { transform: rotate(18deg); } 100% { transform: rotate(-22deg); } }

    /* shin bends more when leg is forward */
    @keyframes shinL  { 0% { transform: rotate(38deg); } 100% { transform: rotate(-8deg); } }
    @keyframes shinR  { 0% { transform: rotate(-8deg); } 100% { transform: rotate(38deg); } }

    @keyframes armL   { 0% { transform: rotate(16deg); } 100% { transform: rotate(-20deg); } }
    @keyframes armR   { 0% { transform: rotate(-20deg); } 100% { transform: rotate(16deg); } }

    /* Speech bubble */
    .bubble{
      position:absolute;
      left: 88px;
      top: 10px;
      max-width: 280px;
      padding: 8px 10px;
      border-radius: 14px;
      background: #fff;
      border: 1px solid rgba(0,0,0,0.14);
      color: rgba(0,0,0,0.80);
      font-size: 12px;
      line-height: 1.25;
      box-shadow: 0 12px 30px rgba(0,0,0,0.10);
      opacity: 0;
      transform: translateY(-6px);
      transition: opacity .16s ease, transform .16s ease;
      white-space: normal;
    }
    .bubble.on{ opacity: 1; transform: translateY(0); }
    .bubble:after{
      content:"";
      position:absolute;
      left: -6px; top: 18px;
      width: 10px; height: 10px;
      background: #fff;
      border-left: 1px solid rgba(0,0,0,0.14);
      border-bottom: 1px solid rgba(0,0,0,0.14);
      transform: rotate(45deg);
    }

    /* --- Soul (more visible + slow) --- */
    .soul{
      position: fixed;
      left: 0; top: 0;
      width: 92px; height: 92px;
      transform: translate(-50%, -50%) scale(1);
      pointer-events: none;
      z-index: 1500;
      opacity: 0;
      filter:
        drop-shadow(0 10px 18px rgba(0,0,0,0.10))
        drop-shadow(0 0 12px rgba(255,255,255,0.95));
      will-change: left, top, opacity;
    }
    .soul svg { width: 92px; height: 92px; display: block; }
    .soul.on{
      opacity: 1;
      transition: opacity 180ms ease;
    }

    /* --- Explosion visuals (fireball) --- */
    .boom{
      position: fixed;
      left: 0; top: 0;
      width: 10px; height: 10px;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 2000;
      mix-blend-mode: multiply;
      filter: saturate(1.25);
    }
    .boom .shock{
      position:absolute;
      left:50%; top:50%;
      width: 20px; height: 20px;
      border-radius: 999px;
      border: 2px solid rgba(255, 70, 0, 0.38);
      transform: translate(-50%, -50%) scale(0.12);
      opacity: 0.95;
      animation: shock 620ms cubic-bezier(.1,.8,.2,1) forwards;
    }
    .boom .flash{
      position:absolute;
      left:50%; top:50%;
      width: 26px; height: 26px;
      border-radius: 999px;
      transform: translate(-50%, -50%) scale(0.12);
      background: radial-gradient(circle at 35% 35%,
        rgba(255,255,255,0.95) 0%,
        rgba(255,220,120,0.95) 22%,
        rgba(255,120,0,0.85) 48%,
        rgba(255,40,0,0.55) 72%,
        rgba(255,40,0,0.0) 100%);
      animation: flash 520ms ease-out forwards;
      opacity: 1;
      filter: blur(0.2px);
    }
    .boom .puff{
      position:absolute;
      left:50%; top:50%;
      width: var(--s);
      height: var(--s);
      border-radius: 999px;
      transform: translate(-50%, -50%) scale(0.12);
      opacity: 0.9;
      background: radial-gradient(circle at 35% 35%,
        rgba(255,255,255,0.85) 0%,
        rgba(255,230,140,0.85) 22%,
        rgba(255,140,0,0.78) 50%,
        rgba(255,55,0,0.45) 78%,
        rgba(255,55,0,0.00) 100%);
      filter: blur(0.4px);
      animation: puff 760ms cubic-bezier(.12,.8,.18,1) forwards;
    }
    .boom .smoke{
      position:absolute;
      left:50%; top:50%;
      width: var(--s);
      height: var(--s);
      border-radius: 999px;
      transform: translate(-50%, -50%) scale(0.12);
      opacity: 0.45;
      background: radial-gradient(circle at 40% 40%,
        rgba(60,60,60,0.35) 0%,
        rgba(60,60,60,0.22) 45%,
        rgba(60,60,60,0.00) 100%);
      filter: blur(0.9px);
      animation: smoke 980ms cubic-bezier(.12,.8,.18,1) forwards;
      mix-blend-mode: normal;
    }
    @keyframes flash{
      0%   { transform: translate(-50%, -50%) scale(0.12); opacity: 0.95; }
      35%  { transform: translate(-50%, -50%) scale(1.25); opacity: 0.75; }
      100% { transform: translate(-50%, -50%) scale(2.25); opacity: 0; }
    }
    @keyframes shock{
      0%   { transform: translate(-50%, -50%) scale(0.12); opacity: 0.9; }
      100% { transform: translate(-50%, -50%) scale(3.2); opacity: 0; }
    }
    @keyframes puff{
      0%   { transform: translate(-50%, -50%) scale(0.18); opacity: 0.9; }
      55%  { opacity: 0.55; }
      100% { transform: translate(calc(-50% + var(--dx)), calc(-50% + var(--dy))) scale(1.65); opacity: 0; }
    }
    @keyframes smoke{
      0%   { transform: translate(-50%, -50%) scale(0.18); opacity: 0.18; }
      35%  { opacity: 0.30; }
      100% { transform: translate(calc(-50% + var(--dx)), calc(-50% + var(--dy))) scale(2.1); opacity: 0; }
    }
  </style>
</head>
<body>
  <header>DL engineer</header>

<script>
(() => {
  const MAX_MEN = 15;
  const EXPLOSION_RADIUS = 140;
  const HEADER_H = 44;

  const prefersReducedMotion = window.matchMedia?.("(prefers-reduced-motion: reduce)")?.matches;
  const CFG = {
    accel: prefersReducedMotion ? 0.004 : 0.020,
    maxSpeed: prefersReducedMotion ? 0.45 : 1.70,
    friction: 0.86,
    catchRadius: 14,
    stopMs: 240,
    speakMs: 1300,
    speakCooldownMs: 650,
  };

  // Souls: slower + longer
  const SOUL = {
    risePxPerMs: 0.34,   // slower
    lifeMs: 3600,
    driftX: 180,
    waveAmp: [18, 26],
    waveFreq: [0.007, 0.011],
    fadeStart: 1300,
  };

  window.addEventListener("contextmenu", (e) => e.preventDefault());

  let target = { x: innerWidth * 0.6, y: innerHeight * 0.6 };
  let hasPointer = false;
  function setTarget(x, y){ hasPointer = true; target.x = x; target.y = y; }
  addEventListener("pointermove", (e) => setTarget(e.clientX, e.clientY), { passive: true });

  const men = [];

  // --- Smooth stickman like your reference, but “clean” ---
  // We draw with thick strokes (round caps) to get a soft silhouette
  function manSVG({ stroke, headFill, outlineStroke, outlineWidth, strokeWidth }) {
    const sw = strokeWidth ?? 12;
    const ow = outlineWidth ?? (sw + 4);
    const hasOutline = !!outlineStroke;

    // Base groups for animation: thighs, shins, arms.
    // Coordinates tuned for a running pose.
    const skeleton = (s, width, extraAttrs="") => `
      <g fill="none" stroke="${s}" stroke-width="${width}" stroke-linecap="round" stroke-linejoin="round" ${extraAttrs}>
        <!-- torso + neck -->
        <path d="M32 26 L32 44" />
        <!-- oval-ish body hint (a subtle curve) -->
        <path d="M32 30 C28 34, 28 38, 32 42" opacity="0.0"/>
      </g>
    `;

    const limbs = (s, width) => `
      <g fill="none" stroke="${s}" stroke-width="${width}" stroke-linecap="round" stroke-linejoin="round">
        <!-- Arms -->
        <g class="anim armL" style="transform-origin: 30px 30px;">
          <path d="M30 30 L19 36" />
        </g>
        <g class="anim armR" style="transform-origin: 34px 30px;">
          <path d="M34 30 L45 36" />
        </g>

        <!-- Legs: each leg is thigh group (anim) + nested shin group (anim) -->
        <g class="anim thighL" style="transform-origin: 30px 44px;">
          <path d="M30 44 L25 54" />
          <g class="anim shinL" style="transform-origin: 25px 54px;">
            <path d="M25 54 L30 62" />
          </g>
        </g>

        <g class="anim thighR" style="transform-origin: 34px 44px;">
          <path d="M34 44 L39 54" />
          <g class="anim shinR" style="transform-origin: 39px 54px;">
            <path d="M39 54 L35 62" />
          </g>
        </g>
      </g>
    `;

    // Head + neck: round
    const head = (fill) => `<circle cx="32" cy="16" r="11" fill="${fill}" />`;
    const neck = (s, width) => `<path d="M32 26 L32 28" stroke="${s}" stroke-width="${width}" stroke-linecap="round" />`;

    // Build SVG with optional outline layer (for souls visibility)
    const outlineLayer = hasOutline ? `
      <g>
        ${head("#fff")}
        ${neck(outlineStroke, ow)}
        ${skeleton(outlineStroke, ow)}
        ${limbs(outlineStroke, ow)}
      </g>
    ` : "";

    const mainLayer = `
      <g>
        ${head(headFill)}
        ${neck(stroke, sw)}
        ${skeleton(stroke, sw)}
        ${limbs(stroke, sw)}
      </g>
    `;

    return `
      <svg viewBox="0 0 64 64" aria-hidden="true">
        ${outlineLayer}
        ${mainLayer}
      </svg>
    `;
  }

  function makeRunnerElement(){
    const el = document.createElement("div");
    el.className = "runner";

    const man = document.createElement("div");
    man.className = "man";
    man.innerHTML = manSVG({
      stroke: "#FFD400",
      headFill: "#FFD400",
      strokeWidth: 12
    });

    const bubble = document.createElement("div");
    bubble.className = "bubble";
    bubble.textContent = "smnth will be later here, now go away";

    el.appendChild(man);
    el.appendChild(bubble);
    document.body.appendChild(el);

    return { el, man, bubble };
  }

  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  function spawnMan(x, y){
    if (men.length >= MAX_MEN) return;
    y = clamp(y, HEADER_H, innerHeight);
    const { el, man, bubble } = makeRunnerElement();
    const m = {
      el, man, bubble,
      alive: true,
      dying: false,
      pos: { x, y },
      vel: { x: 0, y: 0 },
      facing: 1,
      bobT: 0,
      stopUntil: 0,
      speakUntil: 0,
      lastSpeak: 0,
    };
    el.style.left = x + "px";
    el.style.top  = y + "px";
    el.style.setProperty("--runDur", "420ms");
    men.push(m);
  }

  function spawnSoul(fromX, fromY, facing){
    const s = document.createElement("div");
    s.className = "soul";
    s.style.left = fromX + "px";
    s.style.top  = fromY + "px";
    s.innerHTML = manSVG({
      stroke: "#FFFFFF",
      headFill: "#FFFFFF",
      outlineStroke: "rgba(0,0,0,0.28)",   // strong outline so it reads on white
      outlineWidth: 18,
      strokeWidth: 14
    });
    document.body.appendChild(s);

    const svg = s.querySelector("svg");
    svg.style.transformOrigin = "50% 50%";
    svg.style.transform = `scaleX(${facing})`;

    requestAnimationFrame(() => s.classList.add("on"));

    const driftX = (Math.random() - 0.5) * SOUL.driftX;
    const waveA  = SOUL.waveAmp[0] + Math.random() * (SOUL.waveAmp[1] - SOUL.waveAmp[0]);
    const waveF  = SOUL.waveFreq[0] + Math.random() * (SOUL.waveFreq[1] - SOUL.waveFreq[0]);
    const rise   = SOUL.risePxPerMs * (0.9 + Math.random() * 0.25);
    const lifeMs = SOUL.lifeMs * (0.9 + Math.random() * 0.2);

    let t0 = null;
    const x0 = fromX, y0 = fromY;

    function step(ts){
      if (t0 === null) t0 = ts;
      const u = ts - t0;

      const nx = x0 + (driftX * (u / lifeMs)) + Math.sin(u * waveF) * waveA;
      const ny = y0 - (u * rise);

      s.style.left = nx + "px";
      s.style.top  = ny + "px";

      // fade later, slower
      const fadeU = Math.max(0, u - SOUL.fadeStart);
      const alpha = Math.max(0, 1.0 - (fadeU / (lifeMs - SOUL.fadeStart)));
      s.style.opacity = alpha.toFixed(3);

      if (ny < -80 || u >= lifeMs || alpha <= 0.01) {
        s.remove();
        return;
      }
      requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
  }

  function killMan(m){
    if (!m.alive || m.dying) return;
    m.dying = true;

    const facing = m.facing;
    m.el.style.setProperty("--face", String(facing));
    m.el.classList.add("dying");

    setTimeout(() => spawnSoul(m.pos.x, m.pos.y, facing), 80);

    setTimeout(() => {
      m.alive = false;
      m.el.remove();
      const idx = men.indexOf(m);
      if (idx >= 0) men.splice(idx, 1);
    }, 240);
  }

  // Explosion visuals
  function fireballExplosion(x, y){
    const b = document.createElement("div");
    b.className = "boom";
    b.style.left = x + "px";
    b.style.top  = y + "px";

    const shock = document.createElement("div");
    shock.className = "shock";
    const flash = document.createElement("div");
    flash.className = "flash";
    b.appendChild(flash);
    b.appendChild(shock);

    const puffs = 9;
    for (let i = 0; i < puffs; i++) {
      const puff = document.createElement("div");
      puff.className = "puff";
      const ang = (Math.PI * 2) * (i / puffs) + (Math.random() * 0.35);
      const r = 20 + Math.random() * 34;
      puff.style.setProperty("--dx", (Math.cos(ang) * r) + "px");
      puff.style.setProperty("--dy", (Math.sin(ang) * r) + "px");
      puff.style.setProperty("--s", (26 + Math.random() * 34) + "px");
      puff.style.animationDuration = (680 + Math.random() * 240) + "ms";
      b.appendChild(puff);
    }

    const smokeCount = 6;
    for (let i = 0; i < smokeCount; i++) {
      const s = document.createElement("div");
      s.className = "smoke";
      const ang = (Math.PI * 2) * (i / smokeCount) + (Math.random() * 0.6);
      const r = 30 + Math.random() * 44;
      s.style.setProperty("--dx", (Math.cos(ang) * r) + "px");
      s.style.setProperty("--dy", (Math.sin(ang) * r - (8 + Math.random() * 16)) + "px");
      s.style.setProperty("--s", (34 + Math.random() * 44) + "px");
      s.style.animationDelay = (60 + Math.random() * 90) + "ms";
      b.appendChild(s);
    }

    document.body.appendChild(b);
    setTimeout(() => b.remove(), 1100);
  }

  function explode(x, y){
    fireballExplosion(x, y);
    for (const m of [...men]) {
      if (!m.alive) continue;
      const dx = m.pos.x - x;
      const dy = m.pos.y - y;
      if (Math.hypot(dx, dy) <= EXPLOSION_RADIUS) killMan(m);
    }
  }

  // Controls:
  // LMB: spawn (<=15) + target
  // RMB: explosion
  addEventListener("pointerdown", (e) => {
    if (e.button === 2) {
      e.preventDefault();
      explode(e.clientX, e.clientY);
      return;
    }
    setTarget(e.clientX, e.clientY);
    spawnMan(e.clientX, e.clientY);
  }, { passive: false });

  // Seed a couple
  requestAnimationFrame(() => requestAnimationFrame(() => {
    spawnMan(innerWidth * 0.30, innerHeight * 0.58);
    spawnMan(innerWidth * 0.22, innerHeight * 0.66);
    target = { x: innerWidth * 0.70, y: innerHeight * 0.42 };
  }));

  function tick(now){
    const dt = clamp(now - (tick._last || now), 8, 28);
    tick._last = now;

    if (!hasPointer) {
      target.x = innerWidth * 0.70;
      target.y = innerHeight * 0.42;
    }

    for (const m of men) {
      if (!m.alive || m.dying) continue;

      const stopped = now < m.stopUntil;

      if (!stopped) {
        const dx = target.x - m.pos.x;
        const dy = target.y - m.pos.y;
        const dist = Math.hypot(dx, dy) || 1;

        if (Math.abs(dx) > 2) m.facing = dx >= 0 ? 1 : -1;

        const ax = (dx / dist) * CFG.accel * dt;
        const ay = (dy / dist) * CFG.accel * dt;

        m.vel.x = (m.vel.x + ax) * CFG.friction;
        m.vel.y = (m.vel.y + ay) * CFG.friction;

        const sp = Math.hypot(m.vel.x, m.vel.y) || 1;
        const maxV = CFG.maxSpeed * dt;
        if (sp > maxV) {
          m.vel.x = (m.vel.x / sp) * maxV;
          m.vel.y = (m.vel.y / sp) * maxV;
        }

        m.pos.x += m.vel.x;
        m.pos.y += m.vel.y;

        m.pos.x = clamp(m.pos.x, 0, innerWidth);
        m.pos.y = clamp(m.pos.y, HEADER_H, innerHeight);

        // Catch
        if (dist < CFG.catchRadius) {
          m.pos.x = target.x;
          m.pos.y = target.y;
          m.vel.x = 0; m.vel.y = 0;
          m.stopUntil = now + CFG.stopMs;

          if (now - m.lastSpeak > CFG.speakCooldownMs) {
            m.lastSpeak = now;
            m.speakUntil = now + CFG.speakMs;
            m.bubble.classList.add("on");
          }
        }
      }

      if (m.bubble.classList.contains("on") && now > m.speakUntil) {
        m.bubble.classList.remove("on");
      }

      // --- Run animation speed based on actual movement ---
      const speedNow = Math.hypot(m.vel.x, m.vel.y);
      const moving = !stopped && speedNow > 0.12;

      if (moving) m.el.classList.add("moving");
      else m.el.classList.remove("moving");

      // Shorter duration when faster => faster leg cycle
      // clamp duration 300..520ms
      const dur = clamp(520 - speedNow * 140, 300, 520);
      m.el.style.setProperty("--runDur", `${dur.toFixed(0)}ms`);

      // slight vertical bob
      m.bobT += dt * 0.01 * (moving ? 1.8 : 0.6);
      const bob = Math.sin(m.bobT) * (moving ? 1.4 : 0.6);

      m.el.style.left = m.pos.x + "px";
      m.el.style.top  = (m.pos.y + bob) + "px";
      m.man.style.transform = `scaleX(${m.facing})`;
    }

    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
