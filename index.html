<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Minimal Bio + Notes</title>
  <style>
    :root { color-scheme: light; }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: #fff; color: #000; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; }

    /* Full-bleed layout (no extra whitespace) */
    .wrap { height: 100%; width: 100%; display: grid; grid-template-rows: auto 1fr; }
    header{
      display:flex; align-items:baseline; justify-content:space-between;
      padding: 10px 12px;
      border-bottom: 1px solid rgba(0,0,0,0.10);
    }
    .name{ margin:0; font-size:16px; font-weight:650; letter-spacing:-0.2px; }
    .desc{ margin:2px 0 0; font-size:12px; color:rgba(0,0,0,0.60); }
    .meta{ font-size:12px; color:rgba(0,0,0,0.45); white-space:nowrap; }

    main{ position:relative; width:100%; height:100%; }

    /* Minimal write field filling the whole remaining area */
    .note{ position:absolute; inset:0; display:grid; grid-template-rows:auto 1fr auto; }
    .note label{
      padding:10px 12px;
      font-size:12px; color:rgba(0,0,0,0.55);
      display:flex; justify-content:space-between; align-items:center;
      border-bottom:1px solid rgba(0,0,0,0.08);
    }
    textarea{
      width:100%; height:100%;
      border:0; outline:none; resize:none;
      padding:14px 12px;
      font-size:15px; line-height:1.5;
      background:#fff; color:#000;
    }
    .hint{
      padding:10px 12px;
      font-size:12px; color:rgba(0,0,0,0.45);
      border-top:1px solid rgba(0,0,0,0.08);
      display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap;
    }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 11px;
      border: 1px solid rgba(0,0,0,0.14);
      background: rgba(0,0,0,0.03);
      padding: 2px 6px;
      border-radius: 8px;
    }

    /* Pixel sprite runner */
    .runner{
      position:absolute;
      left:0; top:0;
      width:64px; height:64px;
      transform: translate(-200px,-200px);
      pointer-events:none;
      will-change: transform;
      /* a tiny soft shadow but still minimal */
      filter: drop-shadow(0 10px 10px rgba(0,0,0,0.10));
    }
    .runner canvas{
      width:64px; height:64px;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      display:block;
    }

    @media (prefers-reduced-motion: reduce){
      .runner{ display:none; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1 class="name"></h1>
        <p class="desc">DL engineer</p>
      </div>
      <div class="meta">github.io</div>
    </header>

    <main>
      <div class="runner" id="runner" aria-hidden="true">
        <canvas id="sprite" width="16" height="16"></canvas>
      </div>
    </main>
  </div>

<script>
(() => {
  const note = document.getElementById("note");
  const runner = document.getElementById("runner");
  const c = document.getElementById("sprite");
  const ctx = c.getContext("2d", { alpha: true });

  // Focus shortcut
  window.addEventListener("keydown", (e) => {
    if (e.key.toLowerCase() === "k" && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      note.focus();
    }
  });

  const prefersReducedMotion = window.matchMedia?.("(prefers-reduced-motion: reduce)")?.matches;
  if (prefersReducedMotion) return;

  // Cursor target
  let target = { x: window.innerWidth * 0.65, y: window.innerHeight * 0.55 };
  let hasPointer = false;
  function setTarget(e){
    hasPointer = true;
    target.x = e.clientX;
    target.y = e.clientY;
  }
  window.addEventListener("pointermove", setTarget, { passive: true });
  window.addEventListener("pointerdown", setTarget, { passive: true });

  // Physics state
  const pos = { x: window.innerWidth * 0.18, y: window.innerHeight * 0.6 };
  const vel = { x: 0, y: 0 };
  let paused = false;
  let fast = false;

  const cfg = {
    accel: 0.020,
    maxSpeed: 1.45,     // px/ms
    friction: 0.865,
    catchRadius: 14,
    // 2) Stop briefly when “caught”
    stopMs: 180
  };

  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  // 3) No popup / no UI on catch — we only stop briefly.
  let stopUntil = 0;

  // 1) Minimal pixel sprite, inspired by reference: simple head/body/arms/legs, NO FACE.
  // We draw a very simple silhouette with subtle outline.
  const COLORS = {
    fill: "#FFD400",
    shade: "#F2C200",
    outline: "rgba(0,0,0,0.10)"
  };

  function px(x,y,color){ ctx.fillStyle = color; ctx.fillRect(x,y,1,1); }
  function clear(){ ctx.clearRect(0,0,16,16); }

  // facing: only mirror left/right; head always up
  let facing = 1; // 1 right, -1 left

  // A tiny run cycle: legs/arms swap
  const anim = { t: 0, frame: 0, acc: 0 };

  function drawDude(frame, speed01){
    clear();

    // small bob
    const bob = Math.round(Math.sin(anim.t*0.8) * 0.6 * speed01);

    const ox = 6;
    const oy = 2 + bob;

    const F = COLORS.fill, S = COLORS.shade, O = COLORS.outline;

    // HEAD (3x3) - rounded-ish by corners transparent
    //  .XX.
    //  XXXX (but in 3x3 we do a compact circle)
    px(ox+1, oy+0, O); px(ox+2, oy+0, O);
    px(ox+0, oy+1, O); px(ox+1, oy+1, F); px(ox+2, oy+1, F); px(ox+3, oy+1, O);
    px(ox+0, oy+2, O); px(ox+1, oy+2, F); px(ox+2, oy+2, F); px(ox+3, oy+2, O);
    px(ox+1, oy+3, O); px(ox+2, oy+3, O);

    // NECK pixel
    px(ox+1, oy+4, F); px(ox+2, oy+4, F);

    // BODY (simple oval-ish 4x5)
    for (let yy=0; yy<5; yy++){
      for (let xx=0; xx<4; xx++){
        const edge = (xx===0||xx===3||yy===0||yy===4);
        px(ox+xx, oy+5+yy, edge ? O : F);
      }
    }
    // slight shading on lower body
    px(ox+1, oy+8, S); px(ox+2, oy+8, S);

    // ARMS (very minimal sticks)
    const swing = (frame % 2 === 0);
    if (swing){
      // left arm up, right down
      px(ox-1, oy+6, O); px(ox-2, oy+5, F);
      px(ox+4, oy+8, O); px(ox+5, oy+9, F);
    } else {
      // left down, right up
      px(ox-1, oy+8, O); px(ox-2, oy+9, F);
      px(ox+4, oy+6, O); px(ox+5, oy+5, F);
    }

    // LEGS (simple, swap forward/back)
    const leftForward = (frame % 2 === 0);
    const hipY = oy + 10;

    function leg(x, forward){
      px(x, hipY, O);
      px(x, hipY+1, F);
      if (forward){
        px(x+1, hipY+2, F);
        px(x+2, hipY+3, O);
        px(x+3, hipY+3, F);
        px(x+3, hipY+4, O); px(x+4, hipY+4, F); // foot
      } else {
        px(x-1, hipY+2, S);
        px(x-2, hipY+3, O);
        px(x-3, hipY+3, S);
        px(x-3, hipY+4, O); px(x-4, hipY+4, S); // foot
      }
    }

    leg(ox+1, leftForward);
    leg(ox+2, !leftForward);
  }

  function step(now){
    const dt = clamp(now - (step._last || now), 8, 28);
    step._last = now;

    if (!hasPointer) {
      const r = note.getBoundingClientRect();
      target.x = r.left + r.width * 0.75;
      target.y = r.top + r.height * 0.35;
    }

    // Controls
    // Space: pause. Q: speed toggle.
    // (Already requested before; keeping)
    const speedMul = fast ? 1.85 : 1.0;

    // If “stopped due to catch”, just render idle in place
    const stopped = now < stopUntil;

    if (!paused && !stopped) {
      const dx = target.x - pos.x;
      const dy = target.y - pos.y;
      const dist = Math.hypot(dx, dy) || 1;

      // facing by x only (no rotation)
      if (Math.abs(dx) > 2) facing = dx >= 0 ? 1 : -1;

      const ax = (dx / dist) * cfg.accel * dt * speedMul;
      const ay = (dy / dist) * cfg.accel * dt * speedMul;

      vel.x = (vel.x + ax) * cfg.friction;
      vel.y = (vel.y + ay) * cfg.friction;

      const sp = Math.hypot(vel.x, vel.y) || 1;
      const maxV = cfg.maxSpeed * dt * speedMul;
      if (sp > maxV) {
        vel.x = (vel.x / sp) * maxV;
        vel.y = (vel.y / sp) * maxV;
      }

      pos.x += vel.x;
      pos.y += vel.y;

      // keep on screen
      pos.x = clamp(pos.x, 8, window.innerWidth - 8);
      pos.y = clamp(pos.y, 8, window.innerHeight - 8);

      // Catch: 2) STOP briefly when reaches cursor.
      if (dist < cfg.catchRadius) {
        stopUntil = now + cfg.stopMs;
        vel.x = 0; vel.y = 0; // hard stop
      }

      // Sprite animation tied to speed
      const speed01 = clamp(sp / (maxV + 1e-6), 0, 1);
      anim.t += dt * 0.01 * (0.6 + speed01 * 2.0);
      anim.acc += dt * (0.002 + speed01 * 0.010);
      if (anim.acc > 1) { anim.frame = (anim.frame + 1) % 2; anim.acc = 0; }

      drawDude(anim.frame, speed01);
    } else {
      // paused or stopped: idle frame
      drawDude(0, 0);
    }

    runner.style.transform = `translate(${pos.x}px, ${pos.y}px) scaleX(${facing})`;

    requestAnimationFrame(step);
  }

  window.addEventListener("keydown", (e) => {
    if (e.key === " ") { e.preventDefault(); paused = !paused; }
    if (e.key.toLowerCase() === "q") fast = !fast;
  });

  // Initial draw
  drawDude(0, 0);
  requestAnimationFrame(step);
})();
</script>
</body>
</html>
