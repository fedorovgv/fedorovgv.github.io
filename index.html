<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Fedorov Grigory</title>
  <style>
    *{ box-sizing:border-box; }
    html,body{
      height:100%;
      margin:0;
      background:#fff;
      overflow:hidden;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      touch-action:none;
      -webkit-touch-callout:none;
      -webkit-user-select:none;
      user-select:none;
    }

    header{
      position:fixed; left:0; right:0; top:0;
      height:44px; display:flex; align-items:center;
      padding:0 14px; font-size:14px; font-weight:650;
      border-bottom:1px solid rgba(0,0,0,0.10);
      background:#fff; z-index:10;
    }

    #kills{
      position:fixed;
      right:10px; top:10px;
      z-index:50;
      font-size:12px;
      color:rgba(0,0,0,0.75);
      background:rgba(255,255,255,0.82);
      border:1px solid rgba(0,0,0,0.10);
      padding:6px 10px;
      border-radius:14px;
      display:flex;
      gap:8px;
      align-items:center;
      user-select:none;
    }
    #kills .skull{ font-size:14px; }
    #kills .num{ font-weight:700; }
    #kills .lbl{ color:rgba(0,0,0,0.55); }

    #fx{
      position:fixed; inset:0;
      width:100vw; height:100vh;
      pointer-events:none;
      z-index:2000;
    }

    .runner{
      position:fixed; left:0; top:0;
      width:54px; height:54px;
      transform:translate(-50%,-50%);
      pointer-events:none;
      z-index:1000;
      filter:drop-shadow(0 10px 12px rgba(0,0,0,0.10));
      will-change:left,top;
    }

    /* HEALTH BAR: short */
    .hpbar{
      position:absolute;
      width:22px;
      height:6px;
      left:50%;
      top:-9px;
      transform:translateX(-62%);
      border-radius:6px;
      background:rgba(255,255,255,0.9);
      border:1px solid rgba(0,0,0,0.75);
      overflow:hidden;
    }
    .hpfill{
      height:100%;
      width:100%;
      border-radius:5px;
      transform-origin:left center;
      will-change:transform,background;
    }

    .man{ width:54px; height:54px; transform-origin:50% 50%; will-change:transform; }
    .man svg{ width:54px; height:54px; display:block; }

    .bubble{
      position:absolute;
      left:62px; top:-4px;
      max-width:320px;
      padding:8px 10px;
      border-radius:14px;
      background:#fff;
      border:1px solid rgba(0,0,0,0.14);
      color:rgba(0,0,0,0.80);
      font-size:12px;
      line-height:1.25;
      box-shadow:0 12px 30px rgba(0,0,0,0.10);
      opacity:0;
      transform:translateY(-6px);
      transition:opacity .16s ease, transform .16s ease;
      pointer-events:none;
    }
    .bubble.on{ opacity:1; transform:translateY(0); }
    .bubble:after{
      content:"";
      position:absolute;
      left:-6px; top:18px;
      width:10px; height:10px;
      background:#fff;
      border-left:1px solid rgba(0,0,0,0.14);
      border-bottom:1px solid rgba(0,0,0,0.14);
      transform:rotate(45deg);
    }

    .corpse{
      position:fixed; left:0; top:0;
      width:54px; height:54px;
      transform:translate(-50%,-50%);
      pointer-events:none;
      z-index:1400;
      filter:drop-shadow(0 12px 18px rgba(0,0,0,0.10));
      opacity:1;
      will-change:left,top,opacity,transform;
    }
    .corpse svg{ width:54px; height:54px; display:block; }
    .corpse.fade{ opacity:0; transition:opacity 520ms ease; }

    .soul{
      position:fixed; left:0; top:0;
      width:64px; height:64px;
      transform:translate(-50%,-50%);
      pointer-events:none;
      z-index:1500;
      opacity:0;
      filter:drop-shadow(0 10px 18px rgba(0,0,0,0.10));
      will-change:left,top,opacity;
    }
    .soul svg{ width:64px; height:64px; display:block; }
    .soul.on{ opacity:1; transition:opacity 200ms ease; }
  </style>
</head>
<body>
  <header>Fedorov Grigory | DL engineer | Pretrain Infra</header>
  <div id="kills"><span class="skull">ðŸ’€</span><span class="num" id="killsNum">0</span><span class="lbl">page defenders</span></div>
  <canvas id="fx"></canvas>

<script>
(() => {
  const isTouch = (('ontouchstart' in window) || (navigator.maxTouchPoints > 0));
  const DESIRED_MEN = isTouch ? 7 : 10;
  const MAX_MEN     = isTouch ? 7 : 10;

  const HEADER_H = 44;

  // âœ… Much smaller explosion radius
  const EXPLOSION_RADIUS = isTouch ? 120 : 140;

  const EXPLOSION_MAX_DAMAGE = 95;
  const EXPLOSION_FALLOFF_P  = 1.55;

  const MAX_HP = 100;
  const CATCH_PHRASE = "there will be something here, but later, but for now go away";

  const ANNOUNCER = {
    intervalMs: 2200,
    phraseDesktop: "please don't right-click",
    phraseMobile: "please don't double-tap"
  };

  const DOUBLE_TAP = { maxDelayMs: 330, maxDistPx: 24 };

  const CFG = {
    accel: 0.020,
    maxSpeed: 1.70,
    friction: 0.86,
    catchRadius: 14,
    stopMs: 240
  };

  const ORBIT = { r: 56, jitter: 10 };

  const SOUL = {
    risePxPerMs: 0.145,
    lifeMs: 6800,
    driftX: 230,
    waveAmp: [22, 40],
    waveFreq: [0.0045, 0.0082],
    fadeStart: 2900
  };

  const SPEECH = {
    minGapMsBase: 9000,
    gapPanicMultiplier: 0.35,
    durationMs: 1600,
    cooldownPerManMs: 1400,
    heatHalfLifeMs: 8500,
    heatBoostPerExplosion: 1.0
  };

  addEventListener("contextmenu", (e) => e.preventDefault());

  let target = { x: innerWidth * 0.65, y: innerHeight * 0.45 };
  let hasPointer = false;
  function setTarget(x, y){ hasPointer = true; target.x = x; target.y = y; }
  addEventListener("pointermove", (e) => setTarget(e.clientX, e.clientY), { passive: true });

  const men = [];

  let killedCount = 0;
  const killsNumEl = document.getElementById("killsNum");
  function incKills(n=1){
    killedCount += n;
    killsNumEl.textContent = String(killedCount);
  }

  // ===== SVGs (âœ… no wings anywhere) =====
  function baseManSVG({ color, deadEyes, straightLegs=false, soulArmsDown=false }) {
    const fill = color;

    const LIMB = 6.0;
    const THIGH = 7.0;
    const NECK = 3.2;

    const KNEE_CAP_W = 7.4;
    const KNEE_CAP_H = 5.0;

    const eyes = deadEyes ? `
      <g stroke="rgba(0,0,0,0.65)" stroke-width="1.6" stroke-linecap="round">
        <path d="M28.1 12.0 L30.7 14.6" />
        <path d="M30.7 12.0 L28.1 14.6" />
        <path d="M33.3 12.0 L35.9 14.6" />
        <path d="M35.9 12.0 L33.3 14.6" />
      </g>
    ` : "";

    const arms = soulArmsDown ? `
      <path d="M26 30 L26 44" stroke="${fill}" stroke-width="${LIMB}" stroke-linecap="round" />
      <path d="M38 30 L38 44" stroke="${fill}" stroke-width="${LIMB}" stroke-linecap="round" />
    ` : `
      <path d="M24 30 L12 38" stroke="${fill}" stroke-width="${LIMB}" stroke-linecap="round" />
      <path d="M40 30 L52 38" stroke="${fill}" stroke-width="${LIMB}" stroke-linecap="round" />
    `;

    const legs = straightLegs ? `
      <path d="M29 48 L29 76" stroke="${fill}" stroke-width="${LIMB}" stroke-linecap="round" />
      <path d="M35 48 L35 76" stroke="${fill}" stroke-width="${LIMB}" stroke-linecap="round" />
    ` : `
      <path d="M29 48 L23 61" stroke="${fill}" stroke-width="${THIGH}" stroke-linecap="round" />
      <path d="M35 48 L41 61" stroke="${fill}" stroke-width="${THIGH}" stroke-linecap="round" />

      <g class="shinL">
        <path d="M23 61 L30 76" stroke="${fill}" stroke-width="${LIMB}" stroke-linecap="round" />
      </g>
      <g class="shinR">
        <path d="M41 61 L34 76" stroke="${fill}" stroke-width="${LIMB}" stroke-linecap="round" />
      </g>

      <rect x="19.5" y="58.7" width="${KNEE_CAP_W}" height="${KNEE_CAP_H}" rx="3.2" fill="${fill}" />
      <rect x="37.1" y="58.7" width="${KNEE_CAP_W}" height="${KNEE_CAP_H}" rx="3.2" fill="${fill}" />
    `;

    return `
      <svg viewBox="0 0 64 78" aria-hidden="true">
        <circle cx="32" cy="13.5" r="9.3" fill="${fill}" />
        ${eyes}
        <path d="M32 21 L32 29" stroke="${fill}" stroke-width="${NECK}" stroke-linecap="round" />
        <ellipse cx="32" cy="38" rx="8.9" ry="14.5" fill="${fill}" />
        ${arms}
        <ellipse cx="32" cy="48" rx="8.2" ry="6.0" fill="${fill}" />
        ${legs}
      </svg>
    `;
  }

  function aliveSVG(){ return baseManSVG({ color:"#FFD400", deadEyes:false, straightLegs:false, soulArmsDown:false }); }
  function corpseSVG(){return baseManSVG({ color:"#F2F2F2", deadEyes:true,  straightLegs:false, soulArmsDown:false }); }
  function soulSVG(){  return baseManSVG({ color:"#CFCFCF", deadEyes:true,  straightLegs:true,  soulArmsDown:true  }); }

  function makeRunnerElement(){
    const el = document.createElement("div");
    el.className = "runner";

    const hpbar = document.createElement("div");
    hpbar.className = "hpbar";
    const hpfill = document.createElement("div");
    hpfill.className = "hpfill";
    hpbar.appendChild(hpfill);

    const man = document.createElement("div");
    man.className = "man";
    man.innerHTML = aliveSVG();

    const bubble = document.createElement("div");
    bubble.className = "bubble";
    bubble.textContent = "";

    el.appendChild(hpbar);
    el.appendChild(man);
    el.appendChild(bubble);

    document.body.appendChild(el);

    const svg = man.querySelector("svg");
    const parts = {
      shinL: svg.querySelector(".shinL"),
      shinR: svg.querySelector(".shinR"),
    };

    return { el, man, bubble, hpfill, parts };
  }

  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function rand(a,b){ return a + Math.random()*(b-a); }
  function pick(arr){ return arr[(Math.random()*arr.length)|0]; }

  function randomSpawnPoint(){
    const pad = 26;
    const x = rand(pad, innerWidth - pad);
    const y = rand(HEADER_H + pad, innerHeight - pad);
    return { x, y };
  }

  function hpColor(ratio){
    const r = Math.round(255 * (1 - ratio));
    const g = Math.round(200 * ratio + 35);
    const b = 50;
    return `rgb(${r},${g},${b})`;
  }

  function updateHpUI(m){
    const ratio = clamp(m.hp / m.maxHp, 0, 1);
    m.hpfill.style.transform = `scaleX(${ratio.toFixed(3)})`;
    m.hpfill.style.background = hpColor(ratio);
  }

  let announcerRef = null;

  function spawnMan(x, y, { isAnnouncer=false } = {}){
    if (men.length >= MAX_MEN) return;
    y = clamp(y, HEADER_H, innerHeight);

    const { el, man, bubble, hpfill, parts } = makeRunnerElement();

    const m = {
      el, man, bubble, hpfill, parts,
      alive: true,
      pos: { x, y },
      vel: { x: 0, y: 0 },
      facing: 1,
      bobT: 0,
      phase: Math.random() * Math.PI * 2,
      stopUntil: 0,
      speakUntil: 0,
      lastSpeak: 0,
      orbitAngle: null,
      orbitRadius: ORBIT.r + (Math.random() - 0.5) * ORBIT.jitter,
      isAnnouncer,
      nextAnnounceAt: 0,
      hp: MAX_HP,
      maxHp: MAX_HP
    };

    el.style.left = x + "px";
    el.style.top  = y + "px";
    updateHpUI(m);

    men.push(m);
    reassignOrbitSlots();
    applyPose(m, 0, 0);

    if (isAnnouncer) announcerRef = m;
  }

  function reassignOrbitSlots(){
    const orbiters = men.filter(m => m.alive && m.orbitAngle !== null);
    const n = orbiters.length;
    if (n === 0) return;
    const offset = (performance.now() * 0.00035) % (Math.PI * 2);
    for (let i = 0; i < n; i++) orbiters[i].orbitAngle = offset + i * (Math.PI * 2 / n);
  }

  function maintainPopulation(){
    while (men.length < DESIRED_MEN) {
      const p = randomSpawnPoint();
      spawnMan(p.x, p.y);
    }
  }

  function say(m, text, ms){
    if (!m || !m.alive) return;
    const now = performance.now();
    if (now - m.lastSpeak < SPEECH.cooldownPerManMs) return;

    m.lastSpeak = now;
    m.speakUntil = now + ms;
    m.bubble.textContent = text;
    m.bubble.classList.add("on");
  }

  function spawnCorpse(x, y, facing){
    const c = document.createElement("div");
    c.className = "corpse";
    c.style.left = x + "px";
    c.style.top  = y + "px";
    c.innerHTML = corpseSVG();

    const tilt = (Math.random() * 16 - 8);
    c.style.transform = `translate(-50%,-50%) rotate(${tilt}deg)`;

    const svg = c.querySelector("svg");
    svg.style.transformOrigin = "50% 50%";
    svg.style.transform = `scaleX(${facing})`;

    document.body.appendChild(c);
    setTimeout(() => c.classList.add("fade"), 520);
    setTimeout(() => c.remove(), 1100);
  }

  function spawnSoul(fromX, fromY, facing){
    const s = document.createElement("div");
    s.className = "soul";
    s.style.left = fromX + "px";
    s.style.top  = fromY + "px";
    s.innerHTML = soulSVG();
    document.body.appendChild(s);

    const svg = s.querySelector("svg");
    svg.style.transformOrigin = "50% 50%";
    svg.style.transform = `scaleX(${facing})`;

    requestAnimationFrame(() => s.classList.add("on"));

    const driftX = (Math.random() - 0.5) * SOUL.driftX;
    const waveA  = SOUL.waveAmp[0] + Math.random() * (SOUL.waveAmp[1] - SOUL.waveAmp[0]);
    const waveF  = SOUL.waveFreq[0] + Math.random() * (SOUL.waveFreq[1] - SOUL.waveFreq[0]);
    const rise   = SOUL.risePxPerMs * (0.9 + Math.random() * 0.25);
    const lifeMs = SOUL.lifeMs * (0.9 + Math.random() * 0.2);

    let t0 = null;
    const x0 = fromX, y0 = fromY;

    function step(ts){
      if (t0 === null) t0 = ts;
      const u = ts - t0;

      const nx = x0 + (driftX * (u / lifeMs)) + Math.sin(u * waveF) * waveA;
      const ny = y0 - (u * rise);

      s.style.left = nx + "px";
      s.style.top  = ny + "px";

      const fadeU = Math.max(0, u - SOUL.fadeStart);
      const alpha = Math.max(0, 1.0 - (fadeU / (lifeMs - SOUL.fadeStart)));
      s.style.opacity = alpha.toFixed(3);

      if (ny < -110 || u >= lifeMs || alpha <= 0.01) { s.remove(); return; }
      requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
  }

  function killMan(m){
    if (!m.alive) return;

    const x = m.pos.x, y = m.pos.y, facing = m.facing;
    m.alive = false;

    const idx = men.indexOf(m);
    if (idx >= 0) men.splice(idx, 1);

    if (m === announcerRef) announcerRef = null;

    try { m.el.remove(); } catch {}

    incKills(1);
    spawnCorpse(x, y, facing);
    setTimeout(() => spawnSoul(x, y, facing), 90);

    reassignOrbitSlots();
    maintainPopulation();
  }

  // ===== Walking =====
  const KNEE_L = [23, 61];
  const KNEE_R = [41, 61];
  function rot(angleDeg, cx, cy){ return `rotate(${angleDeg.toFixed(2)} ${cx} ${cy})`; }
  function swing01(u){ return Math.sin(Math.PI * u); }
  function lerp(a,b,t){ return a + (b-a)*t; }

  function applyPose(m, speedPerMs, dt){
    const moving = speedPerMs > 0.08 && dt > 0;
    const freq = moving ? (1.75 + speedPerMs * 5.8) : 0.6;
    if (dt) m.phase += (dt / 1000) * (Math.PI * 2) * freq;

    if (!m.parts.shinL || !m.parts.shinR) return;
    const t = (m.phase / (Math.PI * 2)) % 1;

    const base = 0;
    const swingBack = -26;
    const swingFront = 40;
    const stanceMin = -6;
    const stanceMax = 16;

    let leftAngle = base, rightAngle = base;

    if (t < 0.5) {
      const u = t * 2;
      const sv = swing01(u);
      rightAngle = base + lerp(swingBack, swingFront, sv);
      leftAngle  = base + lerp(stanceMax, stanceMin, sv) * 0.78;
    } else {
      const u = (t - 0.5) * 2;
      const sv = swing01(u);
      leftAngle  = base + lerp(swingBack, swingFront, sv);
      rightAngle = base + lerp(stanceMax, stanceMin, sv) * 0.78;
    }

    if (!moving) {
      const w = Math.sin(m.phase) * 4.8;
      leftAngle = base + w * 0.32;
      rightAngle = base - w * 0.32;
    }

    m.parts.shinL.setAttribute("transform", rot(leftAngle, ...KNEE_L));
    m.parts.shinR.setAttribute("transform", rot(rightAngle, ...KNEE_R));
  }

  // ===== Explosion FX =====
  const fx = document.getElementById("fx");
  const ctx = fx.getContext("2d", { alpha:true });

  function resizeFx(){
    const dpr = Math.max(1, Math.min(2, devicePixelRatio || 1));
    fx.width = Math.floor(innerWidth * dpr);
    fx.height = Math.floor(innerHeight * dpr);
    fx.style.width = innerWidth + "px";
    fx.style.height = innerHeight + "px";
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.clearRect(0,0,innerWidth,innerHeight);
  }
  resizeFx();
  addEventListener("resize", resizeFx);

  const explosions = [];
  function addExplosion(x,y){
    const e = { x,y, t:0, life:1200, fire:[], smoke:[], sparks:[] };

    const fireN = 120;
    for (let i=0;i<fireN;i++){
      const ang = rand(0, Math.PI*2);
      const sp  = rand(0.7, 5.0);
      const up  = rand(-1.1, -4.0);
      e.fire.push({ x:x+rand(-3,3), y:y+rand(-3,3), vx:Math.cos(ang)*sp, vy:Math.sin(ang)*sp+up, r:rand(10,28), life:rand(340,800), age:0, wob:rand(0,10) });
    }
    const smokeN = 75;
    for (let i=0;i<smokeN;i++){
      const ang = rand(0, Math.PI*2);
      const sp  = rand(0.2, 2.1);
      e.smoke.push({ x:x+rand(-6,6), y:y+rand(-6,6), vx:Math.cos(ang)*sp, vy:Math.sin(ang)*sp+rand(-2.4,-0.8), r:rand(18,50), life:rand(760,1320), age:0, dens:rand(0.10,0.22), swirl:rand(0.004,0.012) });
    }
    const sparkN = 45;
    for (let i=0;i<sparkN;i++){
      const ang = rand(0, Math.PI*2);
      const sp  = rand(3.0, 10.0);
      e.sparks.push({ x,y, vx:Math.cos(ang)*sp, vy:Math.sin(ang)*sp+rand(-1.6,0.6), life:rand(240,600), age:0, w:rand(1.0,2.0), l:rand(10,24) });
    }

    explosions.push(e);
  }

  function drawExplosion(e, dt){
    e.t += dt;

    ctx.save();
    ctx.globalCompositeOperation = "source-over";
    for (const s of e.smoke){
      s.age += dt;
      const u = s.age / s.life;
      if (u >= 1) continue;

      const swirl = Math.sin((e.t + s.age) * s.swirl * 12) * 0.18;
      s.vx += swirl * dt * 0.002;
      s.vy += (-0.0006) * dt;

      s.x += s.vx * dt * 0.06;
      s.y += s.vy * dt * 0.06;

      const r = s.r * (0.75 + u * 1.55);
      const a = s.dens * (1 - u);

      const g = ctx.createRadialGradient(s.x - r*0.2, s.y - r*0.2, r*0.2, s.x, s.y, r);
      g.addColorStop(0, `rgba(40,40,40,${a*0.92})`);
      g.addColorStop(0.5, `rgba(60,60,60,${a*0.62})`);
      g.addColorStop(1, `rgba(60,60,60,0)`);
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(s.x, s.y, r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();

    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    for (const p of e.fire){
      p.age += dt;
      const u = p.age / p.life;
      if (u >= 1) continue;

      const wob = Math.sin((p.age + p.wob) * 0.02) * 0.05;
      p.vx *= (1 - dt*0.0012);
      p.vy *= (1 - dt*0.0010);
      p.vy += 0.0022 * dt;
      p.vx += wob * dt * 0.03;

      p.x += p.vx * dt * 0.08;
      p.y += p.vy * dt * 0.08;

      const rr = p.r * (0.7 + (1-u)*1.05);
      const a = (1 - u) * 0.70;

      const g = ctx.createRadialGradient(p.x - rr*0.25, p.y - rr*0.25, rr*0.18, p.x, p.y, rr);
      g.addColorStop(0, `rgba(255,255,255,${a*0.98})`);
      g.addColorStop(0.18, `rgba(255,235,160,${a*0.98})`);
      g.addColorStop(0.45, `rgba(255,155,40,${a*0.86})`);
      g.addColorStop(0.78, `rgba(255,70,0,${a*0.55})`);
      g.addColorStop(1, `rgba(60,20,0,0)`);
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(p.x, p.y, rr, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();

    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    for (const sp of e.sparks){
      sp.age += dt;
      const u = sp.age / sp.life;
      if (u >= 1) continue;

      sp.vx *= (1 - dt*0.0016);
      sp.vy *= (1 - dt*0.0012);
      sp.vy += 0.0030 * dt;
      sp.x += sp.vx * dt * 0.12;
      sp.y += sp.vy * dt * 0.12;

      const a = (1-u) * 0.75;
      ctx.strokeStyle = `rgba(255,200,120,${a})`;
      ctx.lineWidth = sp.w;

      const nx = sp.x - sp.vx * sp.l * 0.05;
      const ny = sp.y - sp.vy * sp.l * 0.05;
      ctx.beginPath();
      ctx.moveTo(nx, ny);
      ctx.lineTo(sp.x, sp.y);
      ctx.stroke();
    }
    ctx.restore();

    return e.t >= e.life;
  }

  let lastFx = performance.now();
  function fxLoop(now){
    const dt = Math.min(32, Math.max(8, now - lastFx));
    lastFx = now;

    ctx.save();
    ctx.globalCompositeOperation = "destination-out";
    ctx.fillStyle = "rgba(0,0,0,0.18)";
    ctx.fillRect(0, 0, innerWidth, innerHeight);
    ctx.restore();

    for (let i = explosions.length - 1; i >= 0; i--){
      const done = drawExplosion(explosions[i], dt);
      if (done) explosions.splice(i, 1);
    }
    requestAnimationFrame(fxLoop);
  }
  requestAnimationFrame(fxLoop);

  const desktopWarnings = [
    "please don't right-click",
    "no right-click, please",
    "please stop right-clicking",
    "please don't do that",
    "no explosions, please"
  ];
  const mobileWarnings = [
    "please don't double-tap",
    "no double-tap, please",
    "please stop double-tapping",
    "please don't do that",
    "no explosions, please"
  ];

  let heat = 0;
  let lastHeatUpdate = performance.now();
  function updateHeat(now){
    const dt = now - lastHeatUpdate;
    lastHeatUpdate = now;
    const decay = Math.pow(0.5, dt / SPEECH.heatHalfLifeMs);
    heat *= decay;
  }
  function addHeat(now){
    updateHeat(now);
    heat += SPEECH.heatBoostPerExplosion;
  }
  function heatLevel(now){
    updateHeat(now);
    return 1 - Math.exp(-heat * 0.55);
  }
  function speechPool(){ return isTouch ? mobileWarnings : desktopWarnings; }

  let nextChatterAt = performance.now() + 4500 + Math.random()*4500;
  function scheduleNextChatter(now){
    const hl = heatLevel(now);
    const gapBase = SPEECH.minGapMsBase;
    const gap = gapBase * (1 - hl * (1 - SPEECH.gapPanicMultiplier));
    nextChatterAt = now + gap + Math.random() * gap * 0.85;
  }
  function maybeChatter(now){
    if (now < nextChatterAt) return;
    scheduleNextChatter(now);
    if (men.length === 0) return;

    const hl = heatLevel(now);
    const chance = clamp(0.22 + hl*0.55, 0, 0.90);
    if (Math.random() > chance) return;

    const m = men[(Math.random()*men.length)|0];
    if (!m || !m.alive) return;
    if (m.bubble.classList.contains("on")) return;

    say(m, pick(speechPool()), SPEECH.durationMs);
  }

  function computeDamage(dist){
    if (dist >= EXPLOSION_RADIUS) return 0;
    const t = 1 - (dist / EXPLOSION_RADIUS);
    const shaped = Math.pow(t, EXPLOSION_FALLOFF_P);
    return EXPLOSION_MAX_DAMAGE * shaped;
  }

  function applyExplosionDamage(cx, cy){
    const snapshot = [...men];
    for (const m of snapshot) {
      if (!m.alive) continue;
      const dx = m.pos.x - cx;
      const dy = m.pos.y - cy;
      const d = Math.hypot(dx, dy);
      const dmg = computeDamage(d);
      if (dmg <= 0) continue;

      m.hp = Math.max(0, m.hp - dmg);
      updateHpUI(m);

      if (m.hp <= 0) killMan(m);
    }
  }

  function explode(x, y){
    const now = performance.now();
    addHeat(now);
    addExplosion(x, y);
    applyExplosionDamage(x, y);

    if (men.length > 0) {
      const hl = heatLevel(now);
      const immediateChance = clamp(0.18 + hl*0.52, 0, 0.88);
      if (Math.random() < immediateChance) {
        const m = men[(Math.random()*men.length)|0];
        if (m && m.alive && !m.bubble.classList.contains("on")) {
          say(m, pick(speechPool()), 1200);
        }
      }
    }
  }

  // Desktop: right click
  addEventListener("pointerdown", (e) => {
    setTarget(e.clientX, e.clientY);
    if (e.button === 2) {
      e.preventDefault();
      explode(e.clientX, e.clientY);
    }
  }, { passive: false });

  // Mobile: double tap
  let lastTouchUpTime = 0, lastTouchX = 0, lastTouchY = 0;
  function isNear(x1,y1,x2,y2,maxDist){
    return Math.hypot(x1-x2, y1-y2) <= maxDist;
  }

  addEventListener("pointerdown", (e) => {
    if (e.pointerType === "touch") {
      setTarget(e.clientX, e.clientY);
      e.preventDefault();
    }
  }, { passive: false });

  addEventListener("pointermove", (e) => {
    if (e.pointerType === "touch") {
      setTarget(e.clientX, e.clientY);
      e.preventDefault();
    }
  }, { passive: false });

  addEventListener("pointerup", (e) => {
    if (e.pointerType !== "touch") return;

    e.preventDefault();
    const now = performance.now();
    const x = e.clientX, y = e.clientY;
    setTarget(x, y);

    const dt = now - lastTouchUpTime;
    const close = isNear(x, y, lastTouchX, lastTouchY, DOUBLE_TAP.maxDistPx);

    if (lastTouchUpTime > 0 && dt <= DOUBLE_TAP.maxDelayMs && close) {
      lastTouchUpTime = 0;
      explode(x, y);
      return;
    }

    lastTouchUpTime = now;
    lastTouchX = x;
    lastTouchY = y;
  }, { passive: false });

  // ===== init population =====
  function init(){
    const a = randomSpawnPoint();
    spawnMan(a.x, a.y, { isAnnouncer: true });
    for (let i = 1; i < DESIRED_MEN; i++) {
      const p = randomSpawnPoint();
      spawnMan(p.x, p.y);
    }
    maintainPopulation();
    scheduleNextChatter(performance.now());
    if (announcerRef) announcerRef.nextAnnounceAt = performance.now();
  }
  requestAnimationFrame(() => requestAnimationFrame(init));

  // announcer speech loop
  function announcerTick(now){
    if (announcerRef && announcerRef.alive) {
      const phrase = isTouch ? ANNOUNCER.phraseMobile : ANNOUNCER.phraseDesktop;
      if (now >= announcerRef.nextAnnounceAt && !announcerRef.bubble.classList.contains("on")) {
        announcerRef.lastSpeak = 0;
        say(announcerRef, phrase, 1600);
        announcerRef.nextAnnounceAt = now + ANNOUNCER.intervalMs;
      }
    }
  }

  function clampDt(v){ return Math.max(8, Math.min(28, v)); }

  function tick(now){
    const dt = clampDt(now - (tick._last || now));
    tick._last = now;

    if (!hasPointer) { target.x = innerWidth * 0.65; target.y = innerHeight * 0.45; }

    announcerTick(now);
    maybeChatter(now);

    for (const m of men) {
      if (!m.alive) continue;

      const stopped = now < m.stopUntil;

      let tx = target.x;
      let ty = target.y;
      if (m.orbitAngle !== null) {
        tx = target.x + Math.cos(m.orbitAngle) * m.orbitRadius;
        ty = target.y + Math.sin(m.orbitAngle) * m.orbitRadius;
      }
      ty = clamp(ty, HEADER_H, innerHeight);

      if (!stopped) {
        const dx = tx - m.pos.x;
        const dy = ty - m.pos.y;
        const dist = Math.hypot(dx, dy) || 1;

        if (Math.abs(dx) > 2) m.facing = dx >= 0 ? 1 : -1;

        const ax = (dx / dist) * CFG.accel * dt;
        const ay = (dy / dist) * CFG.accel * dt;

        m.vel.x = (m.vel.x + ax) * CFG.friction;
        m.vel.y = (m.vel.y + ay) * CFG.friction;

        const sp = Math.hypot(m.vel.x, m.vel.y) || 1;
        const maxV = CFG.maxSpeed * dt;
        if (sp > maxV) {
          m.vel.x = (m.vel.x / sp) * maxV;
          m.vel.y = (m.vel.y / sp) * maxV;
        }

        m.pos.x += m.vel.x;
        m.pos.y += m.vel.y;

        m.pos.x = clamp(m.pos.x, 0, innerWidth);
        m.pos.y = clamp(m.pos.y, HEADER_H, innerHeight);

        const distToCursor = Math.hypot(target.x - m.pos.x, target.y - m.pos.y);
        if (distToCursor < CFG.catchRadius) {
          if (m.orbitAngle === null) {
            m.orbitAngle = 0;
            reassignOrbitSlots();
          }

          const ox = target.x + Math.cos(m.orbitAngle) * m.orbitRadius;
          const oy = clamp(target.y + Math.sin(m.orbitAngle) * m.orbitRadius, HEADER_H, innerHeight);

          m.pos.x = ox;
          m.pos.y = oy;
          m.vel.x = 0; m.vel.y = 0;
          m.stopUntil = now + CFG.stopMs;

          if (now - m.lastSpeak > SPEECH.cooldownPerManMs && !m.bubble.classList.contains("on")) {
            say(m, CATCH_PHRASE, 1400);
          }
        }
      }

      if (m.bubble.classList.contains("on") && now > m.speakUntil) {
        m.bubble.classList.remove("on");
      }

      const speedNow = Math.hypot(m.vel.x, m.vel.y);
      const speedPerMs = speedNow / dt;
      applyPose(m, speedPerMs, dt);

      const moving = !stopped && speedPerMs > 0.08;
      m.bobT += dt * 0.01 * (moving ? 1.2 : 0.6);
      const bob = Math.sin(m.bobT) * (moving ? 0.45 : 0.16);

      m.el.style.left = m.pos.x + "px";
      m.el.style.top  = (m.pos.y + bob) + "px";
      m.man.style.transform = `scaleX(${m.facing})`;
    }

    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  addEventListener("resize", () => {
    for (const m of men) {
      m.pos.x = clamp(m.pos.x, 0, innerWidth);
      m.pos.y = clamp(m.pos.y, HEADER_H, innerHeight);
    }
    resizeFx();
  });
})();
</script>
</body>
</html>
